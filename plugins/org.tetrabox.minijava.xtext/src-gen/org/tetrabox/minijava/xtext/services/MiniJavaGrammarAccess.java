/*
 * generated by Xtext 2.12.0
 */
package org.tetrabox.minijava.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MiniJavaGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cPackageKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameQualifiedNameParserRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		private final Assignment cClassesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cClassesClassParserRuleCall_2_0 = (RuleCall)cClassesAssignment_2.eContents().get(0);
		
		//Program:
		//	('package' name=QualifiedName ';')?
		//	imports+=Import*
		//	classes+=Class*;
		@Override public ParserRule getRule() { return rule; }
		
		//('package' name=QualifiedName ';')? imports+=Import* classes+=Class*
		public Group getGroup() { return cGroup; }
		
		//('package' name=QualifiedName ';')?
		public Group getGroup_0() { return cGroup_0; }
		
		//'package'
		public Keyword getPackageKeyword_0_0() { return cPackageKeyword_0_0; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_0_1_0() { return cNameQualifiedNameParserRuleCall_0_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }
		
		//imports+=Import*
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }
		
		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }
		
		//classes+=Class*
		public Assignment getClassesAssignment_2() { return cClassesAssignment_2; }
		
		//Class
		public RuleCall getClassesClassParserRuleCall_2_0() { return cClassesClassParserRuleCall_2_0; }
	}
	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportedNamespaceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0 = (RuleCall)cImportedNamespaceAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Import:
		//	'import' importedNamespace=QualifiedNameWithWildcard ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'import' importedNamespace=QualifiedNameWithWildcard ';'
		public Group getGroup() { return cGroup; }
		
		//'import'
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//importedNamespace=QualifiedNameWithWildcard
		public Assignment getImportedNamespaceAssignment_1() { return cImportedNamespaceAssignment_1; }
		
		//QualifiedNameWithWildcard
		public RuleCall getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0() { return cImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	ID ('.' ID)*;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class QualifiedNameWithWildcardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.QualifiedNameWithWildcard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQualifiedNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//QualifiedNameWithWildcard:
		//	QualifiedName '.*'?;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedName '.*'?
		public Group getGroup() { return cGroup; }
		
		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_0() { return cQualifiedNameParserRuleCall_0; }
		
		//'.*'?
		public Keyword getFullStopAsteriskKeyword_1() { return cFullStopAsteriskKeyword_1; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cExtendsKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSuperclassAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cSuperclassClassCrossReference_2_1_0 = (CrossReference)cSuperclassAssignment_2_1.eContents().get(0);
		private final RuleCall cSuperclassClassQualifiedNameParserRuleCall_2_1_0_1 = (RuleCall)cSuperclassClassCrossReference_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cMembersAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cMembersMemberParserRuleCall_4_0 = (RuleCall)cMembersAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Class:
		//	'class' name=ID ('extends' superclass=[Class|QualifiedName])? '{'
		//	members+=Member*
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'class' name=ID ('extends' superclass=[Class|QualifiedName])? '{' members+=Member* '}'
		public Group getGroup() { return cGroup; }
		
		//'class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//('extends' superclass=[Class|QualifiedName])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'extends'
		public Keyword getExtendsKeyword_2_0() { return cExtendsKeyword_2_0; }
		
		//superclass=[Class|QualifiedName]
		public Assignment getSuperclassAssignment_2_1() { return cSuperclassAssignment_2_1; }
		
		//[Class|QualifiedName]
		public CrossReference getSuperclassClassCrossReference_2_1_0() { return cSuperclassClassCrossReference_2_1_0; }
		
		//QualifiedName
		public RuleCall getSuperclassClassQualifiedNameParserRuleCall_2_1_0_1() { return cSuperclassClassQualifiedNameParserRuleCall_2_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//members+=Member*
		public Assignment getMembersAssignment_4() { return cMembersAssignment_4; }
		
		//Member
		public RuleCall getMembersMemberParserRuleCall_4_0() { return cMembersMemberParserRuleCall_4_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class MemberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Member");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Member:
		//	Field | Method;
		@Override public ParserRule getRule() { return rule; }
		
		//Field | Method
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Field
		public RuleCall getFieldParserRuleCall_0() { return cFieldParserRuleCall_0; }
		
		//Method
		public RuleCall getMethodParserRuleCall_1() { return cMethodParserRuleCall_1; }
	}
	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAccessAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAccessAccessLevelEnumRuleCall_0_0 = (RuleCall)cAccessAssignment_0.eContents().get(0);
		private final RuleCall cTypedDeclarationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Field:
		//	access=AccessLevel? TypedDeclaration ';';
		@Override public ParserRule getRule() { return rule; }
		
		//access=AccessLevel? TypedDeclaration ';'
		public Group getGroup() { return cGroup; }
		
		//access=AccessLevel?
		public Assignment getAccessAssignment_0() { return cAccessAssignment_0; }
		
		//AccessLevel
		public RuleCall getAccessAccessLevelEnumRuleCall_0_0() { return cAccessAccessLevelEnumRuleCall_0_0; }
		
		//TypedDeclaration
		public RuleCall getTypedDeclarationParserRuleCall_1() { return cTypedDeclarationParserRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class MethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Method");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAccessAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAccessAccessLevelEnumRuleCall_0_0 = (RuleCall)cAccessAssignment_0.eContents().get(0);
		private final RuleCall cTypedDeclarationParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParamsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_3_0_0 = (RuleCall)cParamsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParamsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_3_1_1_0 = (RuleCall)cParamsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyBlockParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		
		//Method:
		//	access=AccessLevel? TypedDeclaration
		//	'(' (params+=Parameter (',' params+=Parameter)*)? ')'
		//	body=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//access=AccessLevel? TypedDeclaration '(' (params+=Parameter (',' params+=Parameter)*)? ')' body=Block
		public Group getGroup() { return cGroup; }
		
		//access=AccessLevel?
		public Assignment getAccessAssignment_0() { return cAccessAssignment_0; }
		
		//AccessLevel
		public RuleCall getAccessAccessLevelEnumRuleCall_0_0() { return cAccessAccessLevelEnumRuleCall_0_0; }
		
		//TypedDeclaration
		public RuleCall getTypedDeclarationParserRuleCall_1() { return cTypedDeclarationParserRuleCall_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(params+=Parameter (',' params+=Parameter)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//params+=Parameter
		public Assignment getParamsAssignment_3_0() { return cParamsAssignment_3_0; }
		
		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_0_0() { return cParamsParameterParserRuleCall_3_0_0; }
		
		//(',' params+=Parameter)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//params+=Parameter
		public Assignment getParamsAssignment_3_1_1() { return cParamsAssignment_3_1_1; }
		
		//Parameter
		public RuleCall getParamsParameterParserRuleCall_3_1_1_0() { return cParamsParameterParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//body=Block
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }
		
		//Block
		public RuleCall getBodyBlockParserRuleCall_5_0() { return cBodyBlockParserRuleCall_5_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Parameter");
		private final RuleCall cTypedDeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Parameter:
		//	TypedDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//TypedDeclaration
		public RuleCall getTypedDeclarationParserRuleCall() { return cTypedDeclarationParserRuleCall; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block:
		//	{Block} '{' statements+=Statement* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{Block} '{' statements+=Statement* '}'
		public Group getGroup() { return cGroup; }
		
		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReturnParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cAssignmentParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Statement:
		//	VariableDeclaration | Return | Assignment ';' | IfStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//VariableDeclaration | Return | Assignment ';' | IfStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }
		
		//Return
		public RuleCall getReturnParserRuleCall_1() { return cReturnParserRuleCall_1; }
		
		//Assignment ';'
		public Group getGroup_2() { return cGroup_2; }
		
		//Assignment
		public RuleCall getAssignmentParserRuleCall_2_0() { return cAssignmentParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_3() { return cIfStatementParserRuleCall_3; }
	}
	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypedDeclarationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//VariableDeclaration:
		//	TypedDeclaration '=' expression=Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//TypedDeclaration '=' expression=Expression ';'
		public Group getGroup() { return cGroup; }
		
		//TypedDeclaration
		public RuleCall getTypedDeclarationParserRuleCall_0() { return cTypedDeclarationParserRuleCall_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class ReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Return");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Return:
		//	'return' expression=Expression ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'return' expression=Expression ';'
		public Group getGroup() { return cGroup; }
		
		//'return'
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cThenBlockAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cThenBlockIfBlockParserRuleCall_4_0 = (RuleCall)cThenBlockAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseBlockAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseBlockIfBlockParserRuleCall_5_1_0 = (RuleCall)cElseBlockAssignment_5_1.eContents().get(0);
		
		//IfStatement:
		//	'if' '(' expression=Expression ')' thenBlock=IfBlock (=> 'else' elseBlock=IfBlock)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'if' '(' expression=Expression ')' thenBlock=IfBlock (=> 'else' elseBlock=IfBlock)?
		public Group getGroup() { return cGroup; }
		
		//'if'
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//thenBlock=IfBlock
		public Assignment getThenBlockAssignment_4() { return cThenBlockAssignment_4; }
		
		//IfBlock
		public RuleCall getThenBlockIfBlockParserRuleCall_4_0() { return cThenBlockIfBlockParserRuleCall_4_0; }
		
		//(=> 'else' elseBlock=IfBlock)?
		public Group getGroup_5() { return cGroup_5; }
		
		//=> 'else'
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }
		
		//elseBlock=IfBlock
		public Assignment getElseBlockAssignment_5_1() { return cElseBlockAssignment_5_1; }
		
		//IfBlock
		public RuleCall getElseBlockIfBlockParserRuleCall_5_1_0() { return cElseBlockIfBlockParserRuleCall_5_1_0; }
	}
	public class IfBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.IfBlock");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cStatementsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0 = (RuleCall)cStatementsAssignment_0.eContents().get(0);
		private final RuleCall cBlockParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//IfBlock Block:
		//	statements+=Statement
		//	| Block;
		@Override public ParserRule getRule() { return rule; }
		
		//statements+=Statement | Block
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//statements+=Statement
		public Assignment getStatementsAssignment_0() { return cStatementsAssignment_0; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0_0() { return cStatementsStatementParserRuleCall_0_0; }
		
		//Block
		public RuleCall getBlockParserRuleCall_1() { return cBlockParserRuleCall_1; }
	}
	public class TypedDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.TypedDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(0);
		private final Assignment cTypeRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeRefTypeRefParserRuleCall_0_0 = (RuleCall)cTypeRefAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//fragment TypedDeclaration *:
		//	typeRef=TypeRef name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//typeRef=TypeRef name=ID
		public Group getGroup() { return cGroup; }
		
		//typeRef=TypeRef
		public Assignment getTypeRefAssignment_0() { return cTypeRefAssignment_0; }
		
		//TypeRef
		public RuleCall getTypeRefTypeRefParserRuleCall_0_0() { return cTypeRefTypeRefParserRuleCall_0_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	public class TypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.TypeRef");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIntegerTypeRefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cIntKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanTypeRefAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cBooleanKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cStringTypeRefAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cStringKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		
		//TypeRef:
		//	ClassRef | {IntegerTypeRef} "int" | {BooleanTypeRef} "boolean" | {StringTypeRef} "String";
		@Override public ParserRule getRule() { return rule; }
		
		//ClassRef | {IntegerTypeRef} "int" | {BooleanTypeRef} "boolean" | {StringTypeRef} "String"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ClassRef
		public RuleCall getClassRefParserRuleCall_0() { return cClassRefParserRuleCall_0; }
		
		//{IntegerTypeRef} "int"
		public Group getGroup_1() { return cGroup_1; }
		
		//{IntegerTypeRef}
		public Action getIntegerTypeRefAction_1_0() { return cIntegerTypeRefAction_1_0; }
		
		//"int"
		public Keyword getIntKeyword_1_1() { return cIntKeyword_1_1; }
		
		//{BooleanTypeRef} "boolean"
		public Group getGroup_2() { return cGroup_2; }
		
		//{BooleanTypeRef}
		public Action getBooleanTypeRefAction_2_0() { return cBooleanTypeRefAction_2_0; }
		
		//"boolean"
		public Keyword getBooleanKeyword_2_1() { return cBooleanKeyword_2_1; }
		
		//{StringTypeRef} "String"
		public Group getGroup_3() { return cGroup_3; }
		
		//{StringTypeRef}
		public Action getStringTypeRefAction_3_0() { return cStringTypeRefAction_3_0; }
		
		//"String"
		public Keyword getStringKeyword_3_1() { return cStringKeyword_3_1; }
	}
	public class ClassRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.ClassRef");
		private final Assignment cClassAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cClassClassCrossReference_0 = (CrossReference)cClassAssignment.eContents().get(0);
		private final RuleCall cClassClassQualifiedNameParserRuleCall_0_1 = (RuleCall)cClassClassCrossReference_0.eContents().get(1);
		
		//ClassRef:
		//	class=[Class|QualifiedName];
		@Override public ParserRule getRule() { return rule; }
		
		//class=[Class|QualifiedName]
		public Assignment getClassAssignment() { return cClassAssignment; }
		
		//[Class|QualifiedName]
		public CrossReference getClassClassCrossReference_0() { return cClassClassCrossReference_0; }
		
		//QualifiedName
		public RuleCall getClassClassQualifiedNameParserRuleCall_0_1() { return cClassClassQualifiedNameParserRuleCall_0_1; }
	}
	public class NamedElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.NamedElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMemberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cParameterParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//NamedElement:
		//	Class | Member | VariableDeclaration | Parameter;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Member | VariableDeclaration | Parameter
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Member
		public RuleCall getMemberParserRuleCall_1() { return cMemberParserRuleCall_1; }
		
		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_2() { return cVariableDeclarationParserRuleCall_2; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_3() { return cParameterParserRuleCall_3; }
	}
	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftSelectionExpressionParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightExpressionParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//Assignment:
		//	left=SelectionExpression '=' right=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//left=SelectionExpression '=' right=Expression
		public Group getGroup() { return cGroup; }
		
		//left=SelectionExpression
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//SelectionExpression
		public RuleCall getLeftSelectionExpressionParserRuleCall_0_0() { return cLeftSelectionExpressionParserRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//right=Expression
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Expression
		public RuleCall getRightExpressionParserRuleCall_2_0() { return cRightExpressionParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTerminalExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOrParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Expression:
		//	TerminalExpression | => Or;
		@Override public ParserRule getRule() { return rule; }
		
		//TerminalExpression | => Or
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//TerminalExpression
		public RuleCall getTerminalExpressionParserRuleCall_0() { return cTerminalExpressionParserRuleCall_0; }
		
		//=> Or
		public RuleCall getOrParserRuleCall_1() { return cOrParserRuleCall_1; }
	}
	public class SelectionExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.SelectionExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTerminalExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMemberSelectionReceiverAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cMemberAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cMemberMemberCrossReference_1_2_0 = (CrossReference)cMemberAssignment_1_2.eContents().get(0);
		private final RuleCall cMemberMemberIDTerminalRuleCall_1_2_0_1 = (RuleCall)cMemberMemberCrossReference_1_2_0.eContents().get(1);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Group cGroup_1_3_0 = (Group)cGroup_1_3.eContents().get(0);
		private final Assignment cMethodinvocationAssignment_1_3_0_0 = (Assignment)cGroup_1_3_0.eContents().get(0);
		private final Keyword cMethodinvocationLeftParenthesisKeyword_1_3_0_0_0 = (Keyword)cMethodinvocationAssignment_1_3_0_0.eContents().get(0);
		private final Group cGroup_1_3_0_1 = (Group)cGroup_1_3_0.eContents().get(1);
		private final Assignment cArgsAssignment_1_3_0_1_0 = (Assignment)cGroup_1_3_0_1.eContents().get(0);
		private final RuleCall cArgsExpressionParserRuleCall_1_3_0_1_0_0 = (RuleCall)cArgsAssignment_1_3_0_1_0.eContents().get(0);
		private final Group cGroup_1_3_0_1_1 = (Group)cGroup_1_3_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_3_0_1_1_0 = (Keyword)cGroup_1_3_0_1_1.eContents().get(0);
		private final Assignment cArgsAssignment_1_3_0_1_1_1 = (Assignment)cGroup_1_3_0_1_1.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_1_3_0_1_1_1_0 = (RuleCall)cArgsAssignment_1_3_0_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3_0_2 = (Keyword)cGroup_1_3_0.eContents().get(2);
		
		//SelectionExpression Expression:
		//	TerminalExpression ({MemberSelection.receiver=current} '.'
		//	member=[Member]
		//	=> (methodinvocation?='(' (args+=Expression (',' args+=Expression)*)? ')')?)*;
		@Override public ParserRule getRule() { return rule; }
		
		//TerminalExpression ({MemberSelection.receiver=current} '.' member=[Member] => (methodinvocation?='(' (args+=Expression
		//(',' args+=Expression)*)? ')')?)*
		public Group getGroup() { return cGroup; }
		
		//TerminalExpression
		public RuleCall getTerminalExpressionParserRuleCall_0() { return cTerminalExpressionParserRuleCall_0; }
		
		//({MemberSelection.receiver=current} '.' member=[Member] => (methodinvocation?='(' (args+=Expression (','
		//args+=Expression)*)? ')')?)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MemberSelection.receiver=current}
		public Action getMemberSelectionReceiverAction_1_0() { return cMemberSelectionReceiverAction_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }
		
		//member=[Member]
		public Assignment getMemberAssignment_1_2() { return cMemberAssignment_1_2; }
		
		//[Member]
		public CrossReference getMemberMemberCrossReference_1_2_0() { return cMemberMemberCrossReference_1_2_0; }
		
		//ID
		public RuleCall getMemberMemberIDTerminalRuleCall_1_2_0_1() { return cMemberMemberIDTerminalRuleCall_1_2_0_1; }
		
		//=> (methodinvocation?='(' (args+=Expression (',' args+=Expression)*)? ')')?
		public Group getGroup_1_3() { return cGroup_1_3; }
		
		//methodinvocation?='(' (args+=Expression (',' args+=Expression)*)? ')'
		public Group getGroup_1_3_0() { return cGroup_1_3_0; }
		
		//methodinvocation?='('
		public Assignment getMethodinvocationAssignment_1_3_0_0() { return cMethodinvocationAssignment_1_3_0_0; }
		
		//'('
		public Keyword getMethodinvocationLeftParenthesisKeyword_1_3_0_0_0() { return cMethodinvocationLeftParenthesisKeyword_1_3_0_0_0; }
		
		//(args+=Expression (',' args+=Expression)*)?
		public Group getGroup_1_3_0_1() { return cGroup_1_3_0_1; }
		
		//args+=Expression
		public Assignment getArgsAssignment_1_3_0_1_0() { return cArgsAssignment_1_3_0_1_0; }
		
		//Expression
		public RuleCall getArgsExpressionParserRuleCall_1_3_0_1_0_0() { return cArgsExpressionParserRuleCall_1_3_0_1_0_0; }
		
		//(',' args+=Expression)*
		public Group getGroup_1_3_0_1_1() { return cGroup_1_3_0_1_1; }
		
		//','
		public Keyword getCommaKeyword_1_3_0_1_1_0() { return cCommaKeyword_1_3_0_1_1_0; }
		
		//args+=Expression
		public Assignment getArgsAssignment_1_3_0_1_1_1() { return cArgsAssignment_1_3_0_1_1_1; }
		
		//Expression
		public RuleCall getArgsExpressionParserRuleCall_1_3_0_1_1_1_0() { return cArgsExpressionParserRuleCall_1_3_0_1_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_3_0_2() { return cRightParenthesisKeyword_1_3_0_2; }
	}
	public class TerminalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.TerminalExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cStringConstantAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cValueAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0_1_0 = (RuleCall)cValueAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIntConstantAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBoolConstantAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Alternatives cValueAlternatives_2_1_0 = (Alternatives)cValueAssignment_2_1.eContents().get(0);
		private final Keyword cValueTrueKeyword_2_1_0_0 = (Keyword)cValueAlternatives_2_1_0.eContents().get(0);
		private final Keyword cValueFalseKeyword_2_1_0_1 = (Keyword)cValueAlternatives_2_1_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cThisAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Keyword cThisKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Action cSuperAction_4_0 = (Action)cGroup_4.eContents().get(0);
		private final Keyword cSuperKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Action cNullAction_5_0 = (Action)cGroup_5.eContents().get(0);
		private final Keyword cNullKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Group cGroup_6 = (Group)cAlternatives.eContents().get(6);
		private final Action cNewAction_6_0 = (Action)cGroup_6.eContents().get(0);
		private final Keyword cNewKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cTypeRefAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final CrossReference cTypeRefClassCrossReference_6_2_0 = (CrossReference)cTypeRefAssignment_6_2.eContents().get(0);
		private final RuleCall cTypeRefClassQualifiedNameParserRuleCall_6_2_0_1 = (RuleCall)cTypeRefClassCrossReference_6_2_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_6_4 = (Keyword)cGroup_6.eContents().get(4);
		private final Group cGroup_7 = (Group)cAlternatives.eContents().get(7);
		private final Action cSymbolRefAction_7_0 = (Action)cGroup_7.eContents().get(0);
		private final Assignment cSymbolAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final CrossReference cSymbolSymbolCrossReference_7_1_0 = (CrossReference)cSymbolAssignment_7_1.eContents().get(0);
		private final RuleCall cSymbolSymbolIDTerminalRuleCall_7_1_0_1 = (RuleCall)cSymbolSymbolCrossReference_7_1_0.eContents().get(1);
		
		//TerminalExpression Expression:
		//	{StringConstant} value=STRING | {IntConstant} value=INT | {BoolConstant} value=('true' | 'false') | {This} 'this' |
		//	{Super} 'super' | {Null} 'null' | {New} => 'new' typeRef=[Class|QualifiedName] '(' ')' | {SymbolRef} symbol=[Symbol];
		@Override public ParserRule getRule() { return rule; }
		
		//{StringConstant} value=STRING | {IntConstant} value=INT | {BoolConstant} value=('true' | 'false') | {This} 'this' |
		//{Super} 'super' | {Null} 'null' | {New} => 'new' typeRef=[Class|QualifiedName] '(' ')' | {SymbolRef} symbol=[Symbol]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{StringConstant} value=STRING
		public Group getGroup_0() { return cGroup_0; }
		
		//{StringConstant}
		public Action getStringConstantAction_0_0() { return cStringConstantAction_0_0; }
		
		//value=STRING
		public Assignment getValueAssignment_0_1() { return cValueAssignment_0_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0_1_0() { return cValueSTRINGTerminalRuleCall_0_1_0; }
		
		//{IntConstant} value=INT
		public Group getGroup_1() { return cGroup_1; }
		
		//{IntConstant}
		public Action getIntConstantAction_1_0() { return cIntConstantAction_1_0; }
		
		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }
		
		//{BoolConstant} value=('true' | 'false')
		public Group getGroup_2() { return cGroup_2; }
		
		//{BoolConstant}
		public Action getBoolConstantAction_2_0() { return cBoolConstantAction_2_0; }
		
		//value=('true' | 'false')
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }
		
		//('true' | 'false')
		public Alternatives getValueAlternatives_2_1_0() { return cValueAlternatives_2_1_0; }
		
		//'true'
		public Keyword getValueTrueKeyword_2_1_0_0() { return cValueTrueKeyword_2_1_0_0; }
		
		//'false'
		public Keyword getValueFalseKeyword_2_1_0_1() { return cValueFalseKeyword_2_1_0_1; }
		
		//{This} 'this'
		public Group getGroup_3() { return cGroup_3; }
		
		//{This}
		public Action getThisAction_3_0() { return cThisAction_3_0; }
		
		//'this'
		public Keyword getThisKeyword_3_1() { return cThisKeyword_3_1; }
		
		//{Super} 'super'
		public Group getGroup_4() { return cGroup_4; }
		
		//{Super}
		public Action getSuperAction_4_0() { return cSuperAction_4_0; }
		
		//'super'
		public Keyword getSuperKeyword_4_1() { return cSuperKeyword_4_1; }
		
		//{Null} 'null'
		public Group getGroup_5() { return cGroup_5; }
		
		//{Null}
		public Action getNullAction_5_0() { return cNullAction_5_0; }
		
		//'null'
		public Keyword getNullKeyword_5_1() { return cNullKeyword_5_1; }
		
		//{New} => 'new' typeRef=[Class|QualifiedName] '(' ')'
		public Group getGroup_6() { return cGroup_6; }
		
		//{New}
		public Action getNewAction_6_0() { return cNewAction_6_0; }
		
		//=> 'new'
		public Keyword getNewKeyword_6_1() { return cNewKeyword_6_1; }
		
		//typeRef=[Class|QualifiedName]
		public Assignment getTypeRefAssignment_6_2() { return cTypeRefAssignment_6_2; }
		
		//[Class|QualifiedName]
		public CrossReference getTypeRefClassCrossReference_6_2_0() { return cTypeRefClassCrossReference_6_2_0; }
		
		//QualifiedName
		public RuleCall getTypeRefClassQualifiedNameParserRuleCall_6_2_0_1() { return cTypeRefClassQualifiedNameParserRuleCall_6_2_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_6_3() { return cLeftParenthesisKeyword_6_3; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6_4() { return cRightParenthesisKeyword_6_4; }
		
		//{SymbolRef} symbol=[Symbol]
		public Group getGroup_7() { return cGroup_7; }
		
		//{SymbolRef}
		public Action getSymbolRefAction_7_0() { return cSymbolRefAction_7_0; }
		
		//symbol=[Symbol]
		public Assignment getSymbolAssignment_7_1() { return cSymbolAssignment_7_1; }
		
		//[Symbol]
		public CrossReference getSymbolSymbolCrossReference_7_1_0() { return cSymbolSymbolCrossReference_7_1_0; }
		
		//ID
		public RuleCall getSymbolSymbolIDTerminalRuleCall_7_1_0_1() { return cSymbolSymbolIDTerminalRuleCall_7_1_0_1; }
	}
	public class SymbolElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Symbol");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFieldParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Symbol:
		//	Parameter | Field | VariableDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//Parameter | Field | VariableDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Parameter
		public RuleCall getParameterParserRuleCall_0() { return cParameterParserRuleCall_0; }
		
		//Field
		public RuleCall getFieldParserRuleCall_1() { return cFieldParserRuleCall_1; }
		
		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_2() { return cVariableDeclarationParserRuleCall_2; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Or Expression:
		//	And ({Or.left=current} "||" right=And)*;
		@Override public ParserRule getRule() { return rule; }
		
		//And ({Or.left=current} "||" right=And)*
		public Group getGroup() { return cGroup; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//({Or.left=current} "||" right=And)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }
		
		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }
		
		//right=And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//And
		public RuleCall getRightAndParserRuleCall_1_2_0() { return cRightAndParserRuleCall_1_2_0; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualityParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//And Expression:
		//	Equality ({And.left=current} "&&" right=Equality)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Equality ({And.left=current} "&&" right=Equality)*
		public Group getGroup() { return cGroup; }
		
		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }
		
		//({And.left=current} "&&" right=Equality)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }
		
		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1() { return cAmpersandAmpersandKeyword_1_1; }
		
		//right=Equality
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Equality
		public RuleCall getRightEqualityParserRuleCall_1_2_0() { return cRightEqualityParserRuleCall_1_2_0; }
	}
	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualityLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpEqualsSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpExclamationMarkEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Equality Expression:
		//	Comparison ({Equality.left=current} op=("==" | "!=") right=Comparison)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Comparison ({Equality.left=current} op=("==" | "!=") right=Comparison)*
		public Group getGroup() { return cGroup; }
		
		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }
		
		//({Equality.left=current} op=("==" | "!=") right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Equality.left=current}
		public Action getEqualityLeftAction_1_0() { return cEqualityLeftAction_1_0; }
		
		//op=("==" | "!=")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//("==" | "!=")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//"=="
		public Keyword getOpEqualsSignEqualsSignKeyword_1_1_0_0() { return cOpEqualsSignEqualsSignKeyword_1_1_0_0; }
		
		//"!="
		public Keyword getOpExclamationMarkEqualsSignKeyword_1_1_0_1() { return cOpExclamationMarkEqualsSignKeyword_1_1_0_1; }
		
		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}
	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPlusOrMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cComparisonLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpGreaterThanSignEqualsSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpLessThanSignEqualsSignKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOpGreaterThanSignKeyword_1_1_0_2 = (Keyword)cOpAlternatives_1_1_0.eContents().get(2);
		private final Keyword cOpLessThanSignKeyword_1_1_0_3 = (Keyword)cOpAlternatives_1_1_0.eContents().get(3);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPlusOrMinusParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison Expression:
		//	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*;
		@Override public ParserRule getRule() { return rule; }
		
		//PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
		public Group getGroup() { return cGroup; }
		
		//PlusOrMinus
		public RuleCall getPlusOrMinusParserRuleCall_0() { return cPlusOrMinusParserRuleCall_0; }
		
		//({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Comparison.left=current}
		public Action getComparisonLeftAction_1_0() { return cComparisonLeftAction_1_0; }
		
		//op=(">=" | "<=" | ">" | "<")
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }
		
		//(">=" | "<=" | ">" | "<")
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }
		
		//">="
		public Keyword getOpGreaterThanSignEqualsSignKeyword_1_1_0_0() { return cOpGreaterThanSignEqualsSignKeyword_1_1_0_0; }
		
		//"<="
		public Keyword getOpLessThanSignEqualsSignKeyword_1_1_0_1() { return cOpLessThanSignEqualsSignKeyword_1_1_0_1; }
		
		//">"
		public Keyword getOpGreaterThanSignKeyword_1_1_0_2() { return cOpGreaterThanSignKeyword_1_1_0_2; }
		
		//"<"
		public Keyword getOpLessThanSignKeyword_1_1_0_3() { return cOpLessThanSignKeyword_1_1_0_3; }
		
		//right=PlusOrMinus
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//PlusOrMinus
		public RuleCall getRightPlusOrMinusParserRuleCall_1_2_0() { return cRightPlusOrMinusParserRuleCall_1_2_0; }
	}
	public class PlusOrMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.PlusOrMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulOrDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMulOrDivParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//PlusOrMinus Expression:
		//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*;
		@Override public ParserRule getRule() { return rule; }
		
		//MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup() { return cGroup; }
		
		//MulOrDiv
		public RuleCall getMulOrDivParserRuleCall_0() { return cMulOrDivParserRuleCall_0; }
		
		//(({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{Plus.left=current} '+' | {Minus.left=current} '-'
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }
		
		//{Plus.left=current} '+'
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }
		
		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }
		
		//{Minus.left=current} '-'
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }
		
		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }
		
		//right=MulOrDiv
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//MulOrDiv
		public RuleCall getRightMulOrDivParserRuleCall_1_1_0() { return cRightMulOrDivParserRuleCall_1_1_0; }
	}
	public class MulOrDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.MulOrDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cMulOrDivLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final Alternatives cOpAlternatives_1_0_1_0 = (Alternatives)cOpAssignment_1_0_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_0_1_0_0 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_0_1_0_1 = (Keyword)cOpAlternatives_1_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightPrimaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MulOrDiv Expression:
		//	Primary (({MulOrDiv.left=current} op=('*' | '/')) right=Primary)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary (({MulOrDiv.left=current} op=('*' | '/')) right=Primary)*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//(({MulOrDiv.left=current} op=('*' | '/')) right=Primary)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{MulOrDiv.left=current} op=('*' | '/')
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//{MulOrDiv.left=current}
		public Action getMulOrDivLeftAction_1_0_0() { return cMulOrDivLeftAction_1_0_0; }
		
		//op=('*' | '/')
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }
		
		//('*' | '/')
		public Alternatives getOpAlternatives_1_0_1_0() { return cOpAlternatives_1_0_1_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_1_0_1_0_0() { return cOpAsteriskKeyword_1_0_1_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_1_0_1_0_1() { return cOpSolidusKeyword_1_0_1_0_1; }
		
		//right=Primary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }
		
		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_1_0() { return cRightPrimaryParserRuleCall_1_1_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionPrimaryParserRuleCall_1_2_0 = (RuleCall)cExpressionAssignment_1_2.eContents().get(0);
		private final RuleCall cTerminalExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Primary Expression:
		//	'(' Expression ')' | {Not} => "!" expression=Primary | TerminalExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' Expression ')' | {Not} => "!" expression=Primary | TerminalExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//{Not} => "!" expression=Primary
		public Group getGroup_1() { return cGroup_1; }
		
		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }
		
		//=> "!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }
		
		//expression=Primary
		public Assignment getExpressionAssignment_1_2() { return cExpressionAssignment_1_2; }
		
		//Primary
		public RuleCall getExpressionPrimaryParserRuleCall_1_2_0() { return cExpressionPrimaryParserRuleCall_1_2_0; }
		
		//TerminalExpression
		public RuleCall getTerminalExpressionParserRuleCall_2() { return cTerminalExpressionParserRuleCall_2; }
	}
	
	public class AccessLevelElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.minijava.xtext.MiniJava.AccessLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPRIVATEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPRIVATEPrivateKeyword_0_0 = (Keyword)cPRIVATEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPROTECTEDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPROTECTEDProtectedKeyword_1_0 = (Keyword)cPROTECTEDEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPUBLICEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPUBLICPublicKeyword_2_0 = (Keyword)cPUBLICEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AccessLevel:
		//	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';
		public EnumRule getRule() { return rule; }
		
		//PRIVATE='private' | PROTECTED='protected' | PUBLIC='public'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PRIVATE='private'
		public EnumLiteralDeclaration getPRIVATEEnumLiteralDeclaration_0() { return cPRIVATEEnumLiteralDeclaration_0; }
		
		//'private'
		public Keyword getPRIVATEPrivateKeyword_0_0() { return cPRIVATEPrivateKeyword_0_0; }
		
		//PROTECTED='protected'
		public EnumLiteralDeclaration getPROTECTEDEnumLiteralDeclaration_1() { return cPROTECTEDEnumLiteralDeclaration_1; }
		
		//'protected'
		public Keyword getPROTECTEDProtectedKeyword_1_0() { return cPROTECTEDProtectedKeyword_1_0; }
		
		//PUBLIC='public'
		public EnumLiteralDeclaration getPUBLICEnumLiteralDeclaration_2() { return cPUBLICEnumLiteralDeclaration_2; }
		
		//'public'
		public Keyword getPUBLICPublicKeyword_2_0() { return cPUBLICPublicKeyword_2_0; }
	}
	
	private final ProgramElements pProgram;
	private final ImportElements pImport;
	private final QualifiedNameElements pQualifiedName;
	private final QualifiedNameWithWildcardElements pQualifiedNameWithWildcard;
	private final ClassElements pClass;
	private final MemberElements pMember;
	private final FieldElements pField;
	private final MethodElements pMethod;
	private final AccessLevelElements eAccessLevel;
	private final ParameterElements pParameter;
	private final BlockElements pBlock;
	private final StatementElements pStatement;
	private final VariableDeclarationElements pVariableDeclaration;
	private final ReturnElements pReturn;
	private final IfStatementElements pIfStatement;
	private final IfBlockElements pIfBlock;
	private final TypedDeclarationElements pTypedDeclaration;
	private final TypeRefElements pTypeRef;
	private final ClassRefElements pClassRef;
	private final NamedElementElements pNamedElement;
	private final AssignmentElements pAssignment;
	private final ExpressionElements pExpression;
	private final SelectionExpressionElements pSelectionExpression;
	private final TerminalExpressionElements pTerminalExpression;
	private final SymbolElements pSymbol;
	private final OrElements pOr;
	private final AndElements pAnd;
	private final EqualityElements pEquality;
	private final ComparisonElements pComparison;
	private final PlusOrMinusElements pPlusOrMinus;
	private final MulOrDivElements pMulOrDiv;
	private final PrimaryElements pPrimary;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MiniJavaGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.pImport = new ImportElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pQualifiedNameWithWildcard = new QualifiedNameWithWildcardElements();
		this.pClass = new ClassElements();
		this.pMember = new MemberElements();
		this.pField = new FieldElements();
		this.pMethod = new MethodElements();
		this.eAccessLevel = new AccessLevelElements();
		this.pParameter = new ParameterElements();
		this.pBlock = new BlockElements();
		this.pStatement = new StatementElements();
		this.pVariableDeclaration = new VariableDeclarationElements();
		this.pReturn = new ReturnElements();
		this.pIfStatement = new IfStatementElements();
		this.pIfBlock = new IfBlockElements();
		this.pTypedDeclaration = new TypedDeclarationElements();
		this.pTypeRef = new TypeRefElements();
		this.pClassRef = new ClassRefElements();
		this.pNamedElement = new NamedElementElements();
		this.pAssignment = new AssignmentElements();
		this.pExpression = new ExpressionElements();
		this.pSelectionExpression = new SelectionExpressionElements();
		this.pTerminalExpression = new TerminalExpressionElements();
		this.pSymbol = new SymbolElements();
		this.pOr = new OrElements();
		this.pAnd = new AndElements();
		this.pEquality = new EqualityElements();
		this.pComparison = new ComparisonElements();
		this.pPlusOrMinus = new PlusOrMinusElements();
		this.pMulOrDiv = new MulOrDivElements();
		this.pPrimary = new PrimaryElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.tetrabox.minijava.xtext.MiniJava".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Program:
	//	('package' name=QualifiedName ';')?
	//	imports+=Import*
	//	classes+=Class*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//Import:
	//	'import' importedNamespace=QualifiedNameWithWildcard ';';
	public ImportElements getImportAccess() {
		return pImport;
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}
	
	//QualifiedName:
	//	ID ('.' ID)*;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//QualifiedNameWithWildcard:
	//	QualifiedName '.*'?;
	public QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return pQualifiedNameWithWildcard;
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	//Class:
	//	'class' name=ID ('extends' superclass=[Class|QualifiedName])? '{'
	//	members+=Member*
	//	'}';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//Member:
	//	Field | Method;
	public MemberElements getMemberAccess() {
		return pMember;
	}
	
	public ParserRule getMemberRule() {
		return getMemberAccess().getRule();
	}
	
	//Field:
	//	access=AccessLevel? TypedDeclaration ';';
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}
	
	//Method:
	//	access=AccessLevel? TypedDeclaration
	//	'(' (params+=Parameter (',' params+=Parameter)*)? ')'
	//	body=Block;
	public MethodElements getMethodAccess() {
		return pMethod;
	}
	
	public ParserRule getMethodRule() {
		return getMethodAccess().getRule();
	}
	
	//enum AccessLevel:
	//	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';
	public AccessLevelElements getAccessLevelAccess() {
		return eAccessLevel;
	}
	
	public EnumRule getAccessLevelRule() {
		return getAccessLevelAccess().getRule();
	}
	
	//Parameter:
	//	TypedDeclaration;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Block:
	//	{Block} '{' statements+=Statement* '}';
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//Statement:
	//	VariableDeclaration | Return | Assignment ';' | IfStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//VariableDeclaration:
	//	TypedDeclaration '=' expression=Expression ';';
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return pVariableDeclaration;
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}
	
	//Return:
	//	'return' expression=Expression ';';
	public ReturnElements getReturnAccess() {
		return pReturn;
	}
	
	public ParserRule getReturnRule() {
		return getReturnAccess().getRule();
	}
	
	//IfStatement:
	//	'if' '(' expression=Expression ')' thenBlock=IfBlock (=> 'else' elseBlock=IfBlock)?;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//IfBlock Block:
	//	statements+=Statement
	//	| Block;
	public IfBlockElements getIfBlockAccess() {
		return pIfBlock;
	}
	
	public ParserRule getIfBlockRule() {
		return getIfBlockAccess().getRule();
	}
	
	//fragment TypedDeclaration *:
	//	typeRef=TypeRef name=ID;
	public TypedDeclarationElements getTypedDeclarationAccess() {
		return pTypedDeclaration;
	}
	
	public ParserRule getTypedDeclarationRule() {
		return getTypedDeclarationAccess().getRule();
	}
	
	//TypeRef:
	//	ClassRef | {IntegerTypeRef} "int" | {BooleanTypeRef} "boolean" | {StringTypeRef} "String";
	public TypeRefElements getTypeRefAccess() {
		return pTypeRef;
	}
	
	public ParserRule getTypeRefRule() {
		return getTypeRefAccess().getRule();
	}
	
	//ClassRef:
	//	class=[Class|QualifiedName];
	public ClassRefElements getClassRefAccess() {
		return pClassRef;
	}
	
	public ParserRule getClassRefRule() {
		return getClassRefAccess().getRule();
	}
	
	//NamedElement:
	//	Class | Member | VariableDeclaration | Parameter;
	public NamedElementElements getNamedElementAccess() {
		return pNamedElement;
	}
	
	public ParserRule getNamedElementRule() {
		return getNamedElementAccess().getRule();
	}
	
	//Assignment:
	//	left=SelectionExpression '=' right=Expression;
	public AssignmentElements getAssignmentAccess() {
		return pAssignment;
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}
	
	//Expression:
	//	TerminalExpression | => Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//SelectionExpression Expression:
	//	TerminalExpression ({MemberSelection.receiver=current} '.'
	//	member=[Member]
	//	=> (methodinvocation?='(' (args+=Expression (',' args+=Expression)*)? ')')?)*;
	public SelectionExpressionElements getSelectionExpressionAccess() {
		return pSelectionExpression;
	}
	
	public ParserRule getSelectionExpressionRule() {
		return getSelectionExpressionAccess().getRule();
	}
	
	//TerminalExpression Expression:
	//	{StringConstant} value=STRING | {IntConstant} value=INT | {BoolConstant} value=('true' | 'false') | {This} 'this' |
	//	{Super} 'super' | {Null} 'null' | {New} => 'new' typeRef=[Class|QualifiedName] '(' ')' | {SymbolRef} symbol=[Symbol];
	public TerminalExpressionElements getTerminalExpressionAccess() {
		return pTerminalExpression;
	}
	
	public ParserRule getTerminalExpressionRule() {
		return getTerminalExpressionAccess().getRule();
	}
	
	//Symbol:
	//	Parameter | Field | VariableDeclaration;
	public SymbolElements getSymbolAccess() {
		return pSymbol;
	}
	
	public ParserRule getSymbolRule() {
		return getSymbolAccess().getRule();
	}
	
	//Or Expression:
	//	And ({Or.left=current} "||" right=And)*;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//And Expression:
	//	Equality ({And.left=current} "&&" right=Equality)*;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Equality Expression:
	//	Comparison ({Equality.left=current} op=("==" | "!=") right=Comparison)*;
	public EqualityElements getEqualityAccess() {
		return pEquality;
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}
	
	//Comparison Expression:
	//	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*;
	public ComparisonElements getComparisonAccess() {
		return pComparison;
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}
	
	//PlusOrMinus Expression:
	//	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*;
	public PlusOrMinusElements getPlusOrMinusAccess() {
		return pPlusOrMinus;
	}
	
	public ParserRule getPlusOrMinusRule() {
		return getPlusOrMinusAccess().getRule();
	}
	
	//MulOrDiv Expression:
	//	Primary (({MulOrDiv.left=current} op=('*' | '/')) right=Primary)*;
	public MulOrDivElements getMulOrDivAccess() {
		return pMulOrDiv;
	}
	
	public ParserRule getMulOrDivRule() {
		return getMulOrDivAccess().getRule();
	}
	
	//Primary Expression:
	//	'(' Expression ')' | {Not} => "!" expression=Primary | TerminalExpression;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
