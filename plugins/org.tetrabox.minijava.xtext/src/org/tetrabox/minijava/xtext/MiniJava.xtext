grammar org.tetrabox.minijava.xtext.MiniJava with org.eclipse.xtext.common.Terminals

generate miniJava "http://www.example.org/minijava/MiniJava"

Program:
	('package' name=QualifiedName ';')?
	imports+=Import*
	classes+=Class*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard ';';

QualifiedName:
	ID ('.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;

Class:
	'class' name=ID ('extends' superclass=[Class|QualifiedName])? '{'
	members+=Member*
	'}';

Member:
	Field | Method;

Parameter:
	typeRef=TypeRef name=ID;

Field:
	access=AccessLevel? typeRef=TypeRef name=ID ';';

Method:
	access=AccessLevel? typeRef=TypeRef name=ID
	'(' (params+=Parameter (',' params+=Parameter)*)? ')'
	body=Block;

enum AccessLevel:
	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';

Block:
	{Block} '{' statements+=Statement* '}';

Statement:
	VariableDeclaration |
	Return |
	Assignment ';' |
	IfStatement;
	
	// TODO for loop
	// TODO while loop

VariableDeclaration:
	typeRef=TypeRef name=ID '=' expression=Expression ';';

Return:
	'return' expression=Expression ';';

IfStatement:
	'if' '(' expression=Expression ')' thenBlock=IfBlock
	(=> 'else' elseBlock=IfBlock)?;

IfBlock returns Block:
	statements+=Statement
	| Block;

TypeRef:
	ClassRef |
	{IntegerTypeRef} "int" |
	{BooleanTypeRef} "boolean" |
	{StringTypeRef} "String";

ClassRef:
	class=[Class|QualifiedName];

NamedElement:
	TypedDeclaration | Class;

TypedDeclaration:
	Symbol | Member;

Symbol:
	Parameter | Field | VariableDeclaration;

Assignment:
	left=SelectionExpression '=' right=Expression;

Expression:
	SelectionExpression | => Or;

SelectionExpression returns Expression:
	TerminalExpression
	({MemberSelection.receiver=current} '.'
	member=[Member]
	(methodinvocation?='('
	(args+=Expression (',' args+=Expression)*)? ')')?)*;

TerminalExpression returns Expression:
	{StringConstant} value=STRING |
	{IntConstant} value=INT |
	{BoolConstant} value=('true' | 'false') |
	{This} 'this' |
	{Super} 'super' |
	{Null} 'null' |
	{New} 'new' typeRef=[Class|QualifiedName] '(' ')' | //TODO constructor param list
	{SymbolRef} symbol=[Symbol|ID];

Or returns Expression:
	And ({Or.left=current} "||" right=And)*;

And returns Expression:
	Equality ({And.left=current} "&&" right=Equality)*;

Equality returns Expression:
	Comparison ({Equality.left=current} op=("==" | "!=")
	right=Comparison)*;

Comparison returns Expression:
	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<")
	right=PlusOrMinus)*;

PlusOrMinus returns Expression:
	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-')
	right=MulOrDiv)*;

MulOrDiv returns Expression:
	Primary (({MulOrDiv.left=current} op=('*' | '/'))
	right=Primary)*;

Primary returns Expression:
	'(' Expression ')' |
	{Not} => "!" expression=Primary |
	TerminalExpression;
