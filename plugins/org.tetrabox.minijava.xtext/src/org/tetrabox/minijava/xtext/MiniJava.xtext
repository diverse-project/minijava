grammar org.tetrabox.minijava.xtext.MiniJava with org.eclipse.xtext.common.Terminals

generate miniJava "http://www.example.org/minijava/MiniJava"

Program:
	('package' name=QualifiedName ';')?
	imports+=Import*
	classes+=Class*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard ';';

QualifiedName: ID ('.' ID)* ;

QualifiedNameWithWildcard: QualifiedName '.*'? ;

Class:
	'class' name=ID ('extends' superclass=[Class|QualifiedName])? '{'
		members+=Member*
	'}';

Member:
	Field | Method;

Field:
	access=AccessLevel? TypedDeclaration ';';

Method:
	access=AccessLevel? TypedDeclaration
	'(' (params+=Parameter (',' params+=Parameter)*)? ')'
	body=Block;

enum AccessLevel:
	PRIVATE='private' | PROTECTED='protected' | PUBLIC='public';

Parameter:
	TypedDeclaration;

Block:
	{Block} '{' statements+=Statement* '}';

Statement:
	VariableDeclaration |
	Return |
	Assignment ';'|
	IfStatement;

VariableDeclaration:
	TypedDeclaration '=' expression=Expression ';';

Return:
	'return' expression=Expression ';';

IfStatement:
	'if' '(' expression=Expression ')' thenBlock=IfBlock
	(=>'else' elseBlock=IfBlock)?;

IfBlock returns Block:
	statements+=Statement
	| Block;

Symbol:
	VariableDeclaration | Parameter;

fragment TypedDeclaration *:
	type=[Class|QualifiedName] name=ID
;

NamedElement:
	Class | Member | Symbol
;

Assignment:
	left=SelectionExpression '=' right=Expression
; 

Expression:
	TerminalExpression | =>Or;

SelectionExpression returns Expression:
	TerminalExpression
	(
		{MemberSelection.receiver=current} '.'
		member=[Member]
		=>(methodinvocation?='('
			(args+=Expression (',' args+=Expression)*)? ')'
		)?
	)*;

TerminalExpression returns Expression:
	{StringConstant} value=STRING |
	{IntConstant} value=INT |
	{BoolConstant} value=('true' | 'false') |
	{This} 'this' |
	{Super} 'super' |
	{Null} 'null' |
	{New} =>'new' type=[Class|QualifiedName] '(' ')' |
	{SymbolRef} variable=[Symbol] 
//	'(' Expression ')'
;
	
	
Or returns Expression:
	And (
		{Or.left=current} "||" right=And
	)*;

And returns Expression:
	Equality (
		{And.left=current} "&&" right=Equality
	)*;

Equality returns Expression:
	Comparison (
		{Equality.left=current} op=("==" | "!=")
		right=Comparison
	)*;

Comparison returns Expression:
	PlusOrMinus (
		{Comparison.left=current} op=(">=" | "<=" | ">" | "<")
		right=PlusOrMinus
	)*;

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-')
		right=MulOrDiv
	)*;

MulOrDiv returns Expression:
	Primary (
		({MulOrDiv.left=current} op=('*' | '/'))
		right=Primary
	)*;

Primary returns Expression:
	'(' Expression ')' |
	{Not} =>"!" expression=Primary |
	TerminalExpression;

//Atomic returns Expression:
//	{IntConstant} value=INT |
//	{StringConstant} value=STRING |
//	{BoolConstant} value=('true' | 'false') |
//	{SymbolRef} variable=[Symbol];