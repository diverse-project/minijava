/*
 * generated by Xtext 2.12.0
 */
package org.tetrabox.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MiniJavaGrammarAccess extends AbstractGrammarElementFinder {
	
	public class GoalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Goal");
		private final RuleCall cCompilationUnitParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		// * Source: https://www.cs.purdue.edu/homes/hosking/502/project/grammar.html
		// */ // The Syntactic Grammar
		//Goal:
		//	CompilationUnit;
		@Override public ParserRule getRule() { return rule; }
		
		//CompilationUnit
		public RuleCall getCompilationUnitParserRuleCall() { return cCompilationUnitParserRuleCall; }
	}
	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerLiteralTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanLiteralTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCharacterLiteralTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStringLiteralTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cNullLiteralTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		////Lexical Structure
		////The Java lexical definition describes tokens for Identifier, and the various literals:
		//Literal:
		//	IntegerLiteral | BooleanLiteral | CharacterLiteral | StringLiteral | NullLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//IntegerLiteral | BooleanLiteral | CharacterLiteral | StringLiteral | NullLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntegerLiteral
		public RuleCall getIntegerLiteralTerminalRuleCall_0() { return cIntegerLiteralTerminalRuleCall_0; }
		
		//BooleanLiteral
		public RuleCall getBooleanLiteralTerminalRuleCall_1() { return cBooleanLiteralTerminalRuleCall_1; }
		
		//CharacterLiteral
		public RuleCall getCharacterLiteralTerminalRuleCall_2() { return cCharacterLiteralTerminalRuleCall_2; }
		
		//StringLiteral
		public RuleCall getStringLiteralTerminalRuleCall_3() { return cStringLiteralTerminalRuleCall_3; }
		
		//NullLiteral
		public RuleCall getNullLiteralTerminalRuleCall_4() { return cNullLiteralTerminalRuleCall_4; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferenceTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// In MiniJava we accept identifiers consisting of ASCII characters only, integer literals including octal and hexadecimal, and character and string literals consisting of ASCII characters only, and including escapes.
		//// Types
		//Type:
		//	PrimitiveType | ReferenceType;
		@Override public ParserRule getRule() { return rule; }
		
		//PrimitiveType | ReferenceType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0() { return cPrimitiveTypeParserRuleCall_0; }
		
		//ReferenceType
		public RuleCall getReferenceTypeParserRuleCall_1() { return cReferenceTypeParserRuleCall_1; }
	}
	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cIntKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cBooleanKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//PrimitiveType:
		//	"int" |
		//	"boolean";
		@Override public ParserRule getRule() { return rule; }
		
		//"int" | "boolean"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"int"
		public Keyword getIntKeyword_0() { return cIntKeyword_0; }
		
		//"boolean"
		public Keyword getBooleanKeyword_1() { return cBooleanKeyword_1; }
	}
	public class ReferenceTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ReferenceType");
		private final RuleCall cClassTypeParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ReferenceType:
		//	ClassType
		//	//   	|ArrayType
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall() { return cClassTypeParserRuleCall; }
	}
	public class ClassTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ClassType");
		private final RuleCall cNameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ClassType:
		//	Name;
		@Override public ParserRule getRule() { return rule; }
		
		//Name
		public RuleCall getNameParserRuleCall() { return cNameParserRuleCall; }
	}
	public class ArrayTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ArrayType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cPrimitiveTypeParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketRightSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cClassTypeParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketRightSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cArrayTypeParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cLeftSquareBracketRightSquareBracketKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//ArrayType:
		//	PrimitiveType "[]" | ClassType "[]" | ArrayType "[]";
		@Override public ParserRule getRule() { return rule; }
		
		//PrimitiveType "[]" | ClassType "[]" | ArrayType "[]"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrimitiveType "[]"
		public Group getGroup_0() { return cGroup_0; }
		
		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0_0() { return cPrimitiveTypeParserRuleCall_0_0; }
		
		//"[]"
		public Keyword getLeftSquareBracketRightSquareBracketKeyword_0_1() { return cLeftSquareBracketRightSquareBracketKeyword_0_1; }
		
		//ClassType "[]"
		public Group getGroup_1() { return cGroup_1; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall_1_0() { return cClassTypeParserRuleCall_1_0; }
		
		//"[]"
		public Keyword getLeftSquareBracketRightSquareBracketKeyword_1_1() { return cLeftSquareBracketRightSquareBracketKeyword_1_1; }
		
		//ArrayType "[]"
		public Group getGroup_2() { return cGroup_2; }
		
		//ArrayType
		public RuleCall getArrayTypeParserRuleCall_2_0() { return cArrayTypeParserRuleCall_2_0; }
		
		//"[]"
		public Keyword getLeftSquareBracketRightSquareBracketKeyword_2_1() { return cLeftSquareBracketRightSquareBracketKeyword_2_1; }
	}
	public class NameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSimpleNameParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQualifiedNameParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Names
		//Name:
		//	SimpleName | QualifiedName;
		@Override public ParserRule getRule() { return rule; }
		
		//SimpleName | QualifiedName
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SimpleName
		public RuleCall getSimpleNameParserRuleCall_0() { return cSimpleNameParserRuleCall_0; }
		
		//QualifiedName
		public RuleCall getQualifiedNameParserRuleCall_1() { return cQualifiedNameParserRuleCall_1; }
	}
	public class SimpleNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.SimpleName");
		private final RuleCall cIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SimpleName:
		//	Identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall() { return cIdentifierParserRuleCall; }
	}
	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Identifier");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Identifier:
		//	ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//	Identifier ('.' Identifier)*
		//	//  	Name "." Identifier // original rule
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//Identifier ('.' Identifier)*
		public Group getGroup() { return cGroup; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }
		
		//('.' Identifier)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1_1() { return cIdentifierParserRuleCall_1_1; }
	}
	public class CompilationUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.CompilationUnit");
		private final Assignment cTypesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypesTypeDeclarationParserRuleCall_0 = (RuleCall)cTypesAssignment.eContents().get(0);
		
		////Packages
		//CompilationUnit:
		//	types+=TypeDeclaration+;
		@Override public ParserRule getRule() { return rule; }
		
		//types+=TypeDeclaration+
		public Assignment getTypesAssignment() { return cTypesAssignment; }
		
		//TypeDeclaration
		public RuleCall getTypesTypeDeclarationParserRuleCall_0() { return cTypesTypeDeclarationParserRuleCall_0; }
	}
	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.TypeDeclaration");
		private final RuleCall cClassDeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//TypeDeclaration:
		//	ClassDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//ClassDeclaration
		public RuleCall getClassDeclarationParserRuleCall() { return cClassDeclarationParserRuleCall; }
	}
	public class ModifiersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Modifiers");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cModifiersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cModifiersModifierParserRuleCall_1_0 = (RuleCall)cModifiersAssignment_1.eContents().get(0);
		
		////Modifiers
		//Modifiers:
		//	{Modifier} modifiers+=Modifier*;
		@Override public ParserRule getRule() { return rule; }
		
		//{Modifier} modifiers+=Modifier*
		public Group getGroup() { return cGroup; }
		
		//{Modifier}
		public Action getModifierAction_0() { return cModifierAction_0; }
		
		//modifiers+=Modifier*
		public Assignment getModifiersAssignment_1() { return cModifiersAssignment_1; }
		
		//Modifier
		public RuleCall getModifiersModifierParserRuleCall_1_0() { return cModifiersModifierParserRuleCall_1_0; }
	}
	public class ModifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Modifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPublicKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cStaticKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cNativeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//Modifier:
		//	"public" |
		//	"static" |
		//	"native";
		@Override public ParserRule getRule() { return rule; }
		
		//"public" | "static" | "native"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"public"
		public Keyword getPublicKeyword_0() { return cPublicKeyword_0; }
		
		//"static"
		public Keyword getStaticKeyword_1() { return cStaticKeyword_1; }
		
		//"native"
		public Keyword getNativeKeyword_2() { return cNativeKeyword_2; }
	}
	public class ClassDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ClassDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSuperParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cClassBodyParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		////Classes
		////Class Declaration
		//ClassDeclaration:
		//	'class' Identifier Super? ClassBody;
		@Override public ParserRule getRule() { return rule; }
		
		//'class' Identifier Super? ClassBody
		public Group getGroup() { return cGroup; }
		
		//'class'
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1() { return cIdentifierParserRuleCall_1; }
		
		//Super?
		public RuleCall getSuperParserRuleCall_2() { return cSuperParserRuleCall_2; }
		
		//ClassBody
		public RuleCall getClassBodyParserRuleCall_3() { return cClassBodyParserRuleCall_3; }
	}
	public class SuperElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Super");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtendsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cClassTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Super:
		//	"extends" ClassType;
		@Override public ParserRule getRule() { return rule; }
		
		//"extends" ClassType
		public Group getGroup() { return cGroup; }
		
		//"extends"
		public Keyword getExtendsKeyword_0() { return cExtendsKeyword_0; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall_1() { return cClassTypeParserRuleCall_1; }
	}
	public class ClassBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ClassBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClassBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cClassMembersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cClassMembersClassMemberDeclarationParserRuleCall_2_0 = (RuleCall)cClassMembersAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ClassBody:
		//	{ClassBody} '{' classMembers+=ClassMemberDeclaration* '}';
		@Override public ParserRule getRule() { return rule; }
		
		//{ClassBody} '{' classMembers+=ClassMemberDeclaration* '}'
		public Group getGroup() { return cGroup; }
		
		//{ClassBody}
		public Action getClassBodyAction_0() { return cClassBodyAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//classMembers+=ClassMemberDeclaration*
		public Assignment getClassMembersAssignment_2() { return cClassMembersAssignment_2; }
		
		//ClassMemberDeclaration
		public RuleCall getClassMembersClassMemberDeclarationParserRuleCall_2_0() { return cClassMembersClassMemberDeclarationParserRuleCall_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class ClassMemberDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ClassMemberDeclaration");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFieldDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMethodDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ClassMemberDeclaration:
		//	FieldDeclaration | MethodDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//FieldDeclaration | MethodDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FieldDeclaration
		public RuleCall getFieldDeclarationParserRuleCall_0() { return cFieldDeclarationParserRuleCall_0; }
		
		//MethodDeclaration
		public RuleCall getMethodDeclarationParserRuleCall_1() { return cMethodDeclarationParserRuleCall_1; }
	}
	public class FieldDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.FieldDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModifiersParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cIdentifierListParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		////Field Declarations
		//FieldDeclaration:
		//	Modifiers Type IdentifierList;
		@Override public ParserRule getRule() { return rule; }
		
		//Modifiers Type IdentifierList
		public Group getGroup() { return cGroup; }
		
		//Modifiers
		public RuleCall getModifiersParserRuleCall_0() { return cModifiersParserRuleCall_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }
		
		//IdentifierList
		public RuleCall getIdentifierListParserRuleCall_2() { return cIdentifierListParserRuleCall_2; }
	}
	public class IdentifierListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.IdentifierList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//IdentifierList:
		//	Identifier (',' Identifier)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Identifier (',' Identifier)*
		public Group getGroup() { return cGroup; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }
		
		//(',' Identifier)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1_1() { return cIdentifierParserRuleCall_1_1; }
	}
	public class MethodDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.MethodDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMethodHeaderParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyMethodBodyParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		////Method Declarations
		//MethodDeclaration:
		//	MethodHeader body=MethodBody;
		@Override public ParserRule getRule() { return rule; }
		
		//MethodHeader body=MethodBody
		public Group getGroup() { return cGroup; }
		
		//MethodHeader
		public RuleCall getMethodHeaderParserRuleCall_0() { return cMethodHeaderParserRuleCall_0; }
		
		//body=MethodBody
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//MethodBody
		public RuleCall getBodyMethodBodyParserRuleCall_1_0() { return cBodyMethodBodyParserRuleCall_1_0; }
	}
	public class MethodHeaderElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.MethodHeader");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cModifiersParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_0_1_0 = (RuleCall)cTypeAssignment_0_1.eContents().get(0);
		private final Assignment cDeclaratorAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cDeclaratorMethodDeclaratorParserRuleCall_0_2_0 = (RuleCall)cDeclaratorAssignment_0_2.eContents().get(0);
		private final Assignment cThrowsAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cThrowsThrowsParserRuleCall_0_3_0 = (RuleCall)cThrowsAssignment_0_3.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cModifiersParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cVoidKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cDeclaratorAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cDeclaratorMethodDeclaratorParserRuleCall_1_2_0 = (RuleCall)cDeclaratorAssignment_1_2.eContents().get(0);
		private final Assignment cThrowsAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cThrowsThrowsParserRuleCall_1_3_0 = (RuleCall)cThrowsAssignment_1_3.eContents().get(0);
		
		//MethodHeader:
		//	Modifiers type=Type declarator=MethodDeclarator throws=Throws? | Modifiers "void" declarator=MethodDeclarator
		//	throws=Throws?;
		@Override public ParserRule getRule() { return rule; }
		
		//Modifiers type=Type declarator=MethodDeclarator throws=Throws? | Modifiers "void" declarator=MethodDeclarator
		//throws=Throws?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Modifiers type=Type declarator=MethodDeclarator throws=Throws?
		public Group getGroup_0() { return cGroup_0; }
		
		//Modifiers
		public RuleCall getModifiersParserRuleCall_0_0() { return cModifiersParserRuleCall_0_0; }
		
		//type=Type
		public Assignment getTypeAssignment_0_1() { return cTypeAssignment_0_1; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_0_1_0() { return cTypeTypeParserRuleCall_0_1_0; }
		
		//declarator=MethodDeclarator
		public Assignment getDeclaratorAssignment_0_2() { return cDeclaratorAssignment_0_2; }
		
		//MethodDeclarator
		public RuleCall getDeclaratorMethodDeclaratorParserRuleCall_0_2_0() { return cDeclaratorMethodDeclaratorParserRuleCall_0_2_0; }
		
		//throws=Throws?
		public Assignment getThrowsAssignment_0_3() { return cThrowsAssignment_0_3; }
		
		//Throws
		public RuleCall getThrowsThrowsParserRuleCall_0_3_0() { return cThrowsThrowsParserRuleCall_0_3_0; }
		
		//Modifiers "void" declarator=MethodDeclarator throws=Throws?
		public Group getGroup_1() { return cGroup_1; }
		
		//Modifiers
		public RuleCall getModifiersParserRuleCall_1_0() { return cModifiersParserRuleCall_1_0; }
		
		//"void"
		public Keyword getVoidKeyword_1_1() { return cVoidKeyword_1_1; }
		
		//declarator=MethodDeclarator
		public Assignment getDeclaratorAssignment_1_2() { return cDeclaratorAssignment_1_2; }
		
		//MethodDeclarator
		public RuleCall getDeclaratorMethodDeclaratorParserRuleCall_1_2_0() { return cDeclaratorMethodDeclaratorParserRuleCall_1_2_0; }
		
		//throws=Throws?
		public Assignment getThrowsAssignment_1_3() { return cThrowsAssignment_1_3; }
		
		//Throws
		public RuleCall getThrowsThrowsParserRuleCall_1_3_0() { return cThrowsThrowsParserRuleCall_1_3_0; }
	}
	public class MethodDeclaratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.MethodDeclarator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cFormalParameterListParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//MethodDeclarator:
		//	Identifier "(" FormalParameterList? ")";
		@Override public ParserRule getRule() { return rule; }
		
		//Identifier "(" FormalParameterList? ")"
		public Group getGroup() { return cGroup; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_0() { return cIdentifierParserRuleCall_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//FormalParameterList?
		public RuleCall getFormalParameterListParserRuleCall_2() { return cFormalParameterListParserRuleCall_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class FormalParameterListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.FormalParameterList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFormalParameterParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cFormalParameterParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//FormalParameterList:
		//	FormalParameter (',' FormalParameter)*;
		@Override public ParserRule getRule() { return rule; }
		
		//FormalParameter (',' FormalParameter)*
		public Group getGroup() { return cGroup; }
		
		//FormalParameter
		public RuleCall getFormalParameterParserRuleCall_0() { return cFormalParameterParserRuleCall_0; }
		
		//(',' FormalParameter)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//FormalParameter
		public RuleCall getFormalParameterParserRuleCall_1_1() { return cFormalParameterParserRuleCall_1_1; }
	}
	public class FormalParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.FormalParameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//FormalParameter:
		//	Type Identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//Type Identifier
		public Group getGroup() { return cGroup; }
		
		//Type
		public RuleCall getTypeParserRuleCall_0() { return cTypeParserRuleCall_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1() { return cIdentifierParserRuleCall_1; }
	}
	public class ThrowsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Throws");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cThrowsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cClassTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Throws:
		//	"throws" ClassType;
		@Override public ParserRule getRule() { return rule; }
		
		//"throws" ClassType
		public Group getGroup() { return cGroup; }
		
		//"throws"
		public Keyword getThrowsKeyword_0() { return cThrowsKeyword_0; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall_1() { return cClassTypeParserRuleCall_1; }
	}
	public class MethodBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.MethodBody");
		private final RuleCall cBlockParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//MethodBody:
		//	Block;
		@Override public ParserRule getRule() { return rule; }
		
		//Block
		public RuleCall getBlockParserRuleCall() { return cBlockParserRuleCall; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsBlockStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////Blocks and Statements
		//Block:
		//	{Block} "{" statements+=BlockStatement* "}";
		@Override public ParserRule getRule() { return rule; }
		
		//{Block} "{" statements+=BlockStatement* "}"
		public Group getGroup() { return cGroup; }
		
		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//statements+=BlockStatement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }
		
		//BlockStatement
		public RuleCall getStatementsBlockStatementParserRuleCall_2_0() { return cStatementsBlockStatementParserRuleCall_2_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class BlockStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.BlockStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLocalVariableDeclarationStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BlockStatement:
		//	LocalVariableDeclarationStatement | Statement;
		@Override public ParserRule getRule() { return rule; }
		
		//LocalVariableDeclarationStatement | Statement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LocalVariableDeclarationStatement
		public RuleCall getLocalVariableDeclarationStatementParserRuleCall_0() { return cLocalVariableDeclarationStatementParserRuleCall_0; }
		
		//Statement
		public RuleCall getStatementParserRuleCall_1() { return cStatementParserRuleCall_1; }
	}
	public class LocalVariableDeclarationStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.LocalVariableDeclarationStatement");
		private final RuleCall cLocalVariableDeclarationParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//LocalVariableDeclarationStatement:
		//	LocalVariableDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//LocalVariableDeclaration
		public RuleCall getLocalVariableDeclarationParserRuleCall() { return cLocalVariableDeclarationParserRuleCall; }
	}
	public class LocalVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.LocalVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cVariableDeclaratorsParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//LocalVariableDeclaration:
		//	Type VariableDeclarators;
		@Override public ParserRule getRule() { return rule; }
		
		//Type VariableDeclarators
		public Group getGroup() { return cGroup; }
		
		//Type
		public RuleCall getTypeParserRuleCall_0() { return cTypeParserRuleCall_0; }
		
		//VariableDeclarators
		public RuleCall getVariableDeclaratorsParserRuleCall_1() { return cVariableDeclaratorsParserRuleCall_1; }
	}
	public class VariableDeclaratorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.VariableDeclarators");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableDeclaratorsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableDeclaratorsVariableDeclaratorParserRuleCall_0_0 = (RuleCall)cVariableDeclaratorsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVariableDeclaratorsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariableDeclaratorsVariableDeclaratorParserRuleCall_1_1_0 = (RuleCall)cVariableDeclaratorsAssignment_1_1.eContents().get(0);
		
		//VariableDeclarators:
		//	variableDeclarators+=VariableDeclarator (',' variableDeclarators+=VariableDeclarator)*;
		@Override public ParserRule getRule() { return rule; }
		
		//variableDeclarators+=VariableDeclarator (',' variableDeclarators+=VariableDeclarator)*
		public Group getGroup() { return cGroup; }
		
		//variableDeclarators+=VariableDeclarator
		public Assignment getVariableDeclaratorsAssignment_0() { return cVariableDeclaratorsAssignment_0; }
		
		//VariableDeclarator
		public RuleCall getVariableDeclaratorsVariableDeclaratorParserRuleCall_0_0() { return cVariableDeclaratorsVariableDeclaratorParserRuleCall_0_0; }
		
		//(',' variableDeclarators+=VariableDeclarator)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//variableDeclarators+=VariableDeclarator
		public Assignment getVariableDeclaratorsAssignment_1_1() { return cVariableDeclaratorsAssignment_1_1; }
		
		//VariableDeclarator
		public RuleCall getVariableDeclaratorsVariableDeclaratorParserRuleCall_1_1_0() { return cVariableDeclaratorsVariableDeclaratorParserRuleCall_1_1_0; }
	}
	public class VariableDeclaratorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.VariableDeclarator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cVariableDeclaratorAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIdentifierParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		
		//VariableDeclarator:
		//	{VariableDeclarator} Identifier | Identifier "=" Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{VariableDeclarator} Identifier | Identifier "=" Expression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{VariableDeclarator} Identifier
		public Group getGroup_0() { return cGroup_0; }
		
		//{VariableDeclarator}
		public Action getVariableDeclaratorAction_0_0() { return cVariableDeclaratorAction_0_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_0_1() { return cIdentifierParserRuleCall_0_1; }
		
		//Identifier "=" Expression
		public Group getGroup_1() { return cGroup_1; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1_0() { return cIdentifierParserRuleCall_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_1_2() { return cExpressionParserRuleCall_1_2; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIfThenStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIfThenElseStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cWhileStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDoWhileStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cReturnStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cBreakStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cContinueStatementParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cForStatementParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//Statement:
		//	Block | ExpressionStatement | IfThenStatement | IfThenElseStatement | WhileStatement | DoWhileStatement |
		//	ReturnStatement | BreakStatement | ContinueStatement | ForStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//Block | ExpressionStatement | IfThenStatement | IfThenElseStatement | WhileStatement | DoWhileStatement |
		//ReturnStatement | BreakStatement | ContinueStatement | ForStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Block
		public RuleCall getBlockParserRuleCall_0() { return cBlockParserRuleCall_0; }
		
		//ExpressionStatement
		public RuleCall getExpressionStatementParserRuleCall_1() { return cExpressionStatementParserRuleCall_1; }
		
		//IfThenStatement
		public RuleCall getIfThenStatementParserRuleCall_2() { return cIfThenStatementParserRuleCall_2; }
		
		//IfThenElseStatement
		public RuleCall getIfThenElseStatementParserRuleCall_3() { return cIfThenElseStatementParserRuleCall_3; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_4() { return cWhileStatementParserRuleCall_4; }
		
		//DoWhileStatement
		public RuleCall getDoWhileStatementParserRuleCall_5() { return cDoWhileStatementParserRuleCall_5; }
		
		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_6() { return cReturnStatementParserRuleCall_6; }
		
		//BreakStatement
		public RuleCall getBreakStatementParserRuleCall_7() { return cBreakStatementParserRuleCall_7; }
		
		//ContinueStatement
		public RuleCall getContinueStatementParserRuleCall_8() { return cContinueStatementParserRuleCall_8; }
		
		//ForStatement
		public RuleCall getForStatementParserRuleCall_9() { return cForStatementParserRuleCall_9; }
	}
	public class ExpressionStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ExpressionStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cExpressionStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cStatementExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementExpressionStatementExpressionParserRuleCall_1_0 = (RuleCall)cStatementExpressionAssignment_1.eContents().get(0);
		
		//ExpressionStatement:
		//	{ExpressionStatement} statementExpression=StatementExpression?;
		@Override public ParserRule getRule() { return rule; }
		
		//{ExpressionStatement} statementExpression=StatementExpression?
		public Group getGroup() { return cGroup; }
		
		//{ExpressionStatement}
		public Action getExpressionStatementAction_0() { return cExpressionStatementAction_0; }
		
		//statementExpression=StatementExpression?
		public Assignment getStatementExpressionAssignment_1() { return cStatementExpressionAssignment_1; }
		
		//StatementExpression
		public RuleCall getStatementExpressionStatementExpressionParserRuleCall_1_0() { return cStatementExpressionStatementExpressionParserRuleCall_1_0; }
	}
	public class StatementExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.StatementExpression");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StatementExpression:
		//	Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}
	public class IfThenStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.IfThenStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		
		//IfThenStatement:
		//	"if" "(" Expression ")" statement=Statement;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" "(" Expression ")" statement=Statement
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }
	}
	public class IfThenElseStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.IfThenElseStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementIfAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementIfStatementParserRuleCall_4_0 = (RuleCall)cStatementIfAssignment_4.eContents().get(0);
		private final Keyword cElseKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cStatementElseAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementElseStatementParserRuleCall_6_0 = (RuleCall)cStatementElseAssignment_6.eContents().get(0);
		
		//IfThenElseStatement:
		//	"if" "(" Expression ")" statementIf=Statement "else" statementElse=Statement;
		@Override public ParserRule getRule() { return rule; }
		
		//"if" "(" Expression ")" statementIf=Statement "else" statementElse=Statement
		public Group getGroup() { return cGroup; }
		
		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//statementIf=Statement
		public Assignment getStatementIfAssignment_4() { return cStatementIfAssignment_4; }
		
		//Statement
		public RuleCall getStatementIfStatementParserRuleCall_4_0() { return cStatementIfStatementParserRuleCall_4_0; }
		
		//"else"
		public Keyword getElseKeyword_5() { return cElseKeyword_5; }
		
		//statementElse=Statement
		public Assignment getStatementElseAssignment_6() { return cStatementElseAssignment_6; }
		
		//Statement
		public RuleCall getStatementElseStatementParserRuleCall_6_0() { return cStatementElseStatementParserRuleCall_6_0; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cStatementAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cStatementStatementParserRuleCall_4_0 = (RuleCall)cStatementAssignment_4.eContents().get(0);
		
		//WhileStatement:
		//	"while" "(" Expression ")" statement=Statement;
		@Override public ParserRule getRule() { return rule; }
		
		//"while" "(" Expression ")" statement=Statement
		public Group getGroup() { return cGroup; }
		
		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_2() { return cExpressionParserRuleCall_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//statement=Statement
		public Assignment getStatementAssignment_4() { return cStatementAssignment_4; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_4_0() { return cStatementStatementParserRuleCall_4_0; }
	}
	public class DoWhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.DoWhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cStatementAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cStatementStatementParserRuleCall_1_0 = (RuleCall)cStatementAssignment_1.eContents().get(0);
		private final Keyword cWhileKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpressionExpressionParserRuleCall_4_0 = (RuleCall)cExpressionAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//DoWhileStatement:
		//	"do" statement=Statement "while" "(" expression=Expression ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"do" statement=Statement "while" "(" expression=Expression ")"
		public Group getGroup() { return cGroup; }
		
		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }
		
		//statement=Statement
		public Assignment getStatementAssignment_1() { return cStatementAssignment_1; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_1_0() { return cStatementStatementParserRuleCall_1_0; }
		
		//"while"
		public Keyword getWhileKeyword_2() { return cWhileKeyword_2; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_4() { return cExpressionAssignment_4; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_4_0() { return cExpressionExpressionParserRuleCall_4_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//ReturnStatement:
		//	"return" Expression?;
		@Override public ParserRule getRule() { return rule; }
		
		//"return" Expression?
		public Group getGroup() { return cGroup; }
		
		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }
		
		//Expression?
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }
	}
	public class BreakStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.BreakStatement");
		private final Keyword cBreakKeyword = (Keyword)rule.eContents().get(1);
		
		//BreakStatement:
		//	"break";
		@Override public ParserRule getRule() { return rule; }
		
		//"break"
		public Keyword getBreakKeyword() { return cBreakKeyword; }
	}
	public class ContinueStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ContinueStatement");
		private final Keyword cContinueKeyword = (Keyword)rule.eContents().get(1);
		
		//ContinueStatement:
		//	"continue";
		@Override public ParserRule getRule() { return rule; }
		
		//"continue"
		public Keyword getContinueKeyword() { return cContinueKeyword; }
	}
	public class ForStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ForStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cForInitParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpressionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpressionExpressionParserRuleCall_4_0 = (RuleCall)cExpressionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cUpdateAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cUpdateForUpdateParserRuleCall_6_0 = (RuleCall)cUpdateAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cStatementAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cStatementStatementParserRuleCall_8_0 = (RuleCall)cStatementAssignment_8.eContents().get(0);
		
		//ForStatement:
		//	"for" "(" ForInit? ";" expression=Expression? ";" update=ForUpdate? ")" statement=Statement;
		@Override public ParserRule getRule() { return rule; }
		
		//"for" "(" ForInit? ";" expression=Expression? ";" update=ForUpdate? ")" statement=Statement
		public Group getGroup() { return cGroup; }
		
		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//ForInit?
		public RuleCall getForInitParserRuleCall_2() { return cForInitParserRuleCall_2; }
		
		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
		
		//expression=Expression?
		public Assignment getExpressionAssignment_4() { return cExpressionAssignment_4; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_4_0() { return cExpressionExpressionParserRuleCall_4_0; }
		
		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
		
		//update=ForUpdate?
		public Assignment getUpdateAssignment_6() { return cUpdateAssignment_6; }
		
		//ForUpdate
		public RuleCall getUpdateForUpdateParserRuleCall_6_0() { return cUpdateForUpdateParserRuleCall_6_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
		
		//statement=Statement
		public Assignment getStatementAssignment_8() { return cStatementAssignment_8; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_8_0() { return cStatementStatementParserRuleCall_8_0; }
	}
	public class ForInitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ForInit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStatementExpressionListParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLocalVariableDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ForInit:
		//	StatementExpressionList | LocalVariableDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//StatementExpressionList | LocalVariableDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//StatementExpressionList
		public RuleCall getStatementExpressionListParserRuleCall_0() { return cStatementExpressionListParserRuleCall_0; }
		
		//LocalVariableDeclaration
		public RuleCall getLocalVariableDeclarationParserRuleCall_1() { return cLocalVariableDeclarationParserRuleCall_1; }
	}
	public class ForUpdateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ForUpdate");
		private final RuleCall cStatementExpressionListParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//ForUpdate:
		//	StatementExpressionList;
		@Override public ParserRule getRule() { return rule; }
		
		//StatementExpressionList
		public RuleCall getStatementExpressionListParserRuleCall() { return cStatementExpressionListParserRuleCall; }
	}
	public class StatementExpressionListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.StatementExpressionList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStatementExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStatementExpressionsStatementExpressionParserRuleCall_0_0 = (RuleCall)cStatementExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cStatementExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cStatementExpressionsStatementExpressionParserRuleCall_1_1_0 = (RuleCall)cStatementExpressionsAssignment_1_1.eContents().get(0);
		
		//StatementExpressionList:
		//	statementExpressions+=StatementExpression ("," statementExpressions+=StatementExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//statementExpressions+=StatementExpression ("," statementExpressions+=StatementExpression)*
		public Group getGroup() { return cGroup; }
		
		//statementExpressions+=StatementExpression
		public Assignment getStatementExpressionsAssignment_0() { return cStatementExpressionsAssignment_0; }
		
		//StatementExpression
		public RuleCall getStatementExpressionsStatementExpressionParserRuleCall_0_0() { return cStatementExpressionsStatementExpressionParserRuleCall_0_0; }
		
		//("," statementExpressions+=StatementExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//statementExpressions+=StatementExpression
		public Assignment getStatementExpressionsAssignment_1_1() { return cStatementExpressionsAssignment_1_1; }
		
		//StatementExpression
		public RuleCall getStatementExpressionsStatementExpressionParserRuleCall_1_1_0() { return cStatementExpressionsStatementExpressionParserRuleCall_1_1_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConditionalExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Expressions
		//Expression:
		//	ConditionalExpression | AssignmentExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//ConditionalExpression | AssignmentExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ConditionalExpression
		public RuleCall getConditionalExpressionParserRuleCall_0() { return cConditionalExpressionParserRuleCall_0; }
		
		//AssignmentExpression
		public RuleCall getAssignmentExpressionParserRuleCall_1() { return cAssignmentExpressionParserRuleCall_1; }
	}
	public class AssignmentExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.AssignmentExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftConditionalExpressionParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightExpressionParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//AssignmentExpression:
		//	left=ConditionalExpression "=" right=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//left=ConditionalExpression "=" right=Expression
		public Group getGroup() { return cGroup; }
		
		//left=ConditionalExpression
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//ConditionalExpression
		public RuleCall getLeftConditionalExpressionParserRuleCall_0_0() { return cLeftConditionalExpressionParserRuleCall_0_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//right=Expression
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//Expression
		public RuleCall getRightExpressionParserRuleCall_2_0() { return cRightExpressionParserRuleCall_2_0; }
	}
	public class ConditionalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ConditionalExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInfixExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cConditionInfixExpressionParserRuleCall_1_0_0 = (RuleCall)cConditionAssignment_1_0.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExpressionIfAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpressionIfExpressionParserRuleCall_1_2_0 = (RuleCall)cExpressionIfAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cExpressionElseAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cExpressionElseConditionalExpressionParserRuleCall_1_4_0 = (RuleCall)cExpressionElseAssignment_1_4.eContents().get(0);
		
		//ConditionalExpression:
		//	InfixExpression | condition=InfixExpression "?" expressionIf=Expression ":" expressionElse=ConditionalExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//InfixExpression | condition=InfixExpression "?" expressionIf=Expression ":" expressionElse=ConditionalExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//InfixExpression
		public RuleCall getInfixExpressionParserRuleCall_0() { return cInfixExpressionParserRuleCall_0; }
		
		//condition=InfixExpression "?" expressionIf=Expression ":" expressionElse=ConditionalExpression
		public Group getGroup_1() { return cGroup_1; }
		
		//condition=InfixExpression
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }
		
		//InfixExpression
		public RuleCall getConditionInfixExpressionParserRuleCall_1_0_0() { return cConditionInfixExpressionParserRuleCall_1_0_0; }
		
		//"?"
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }
		
		//expressionIf=Expression
		public Assignment getExpressionIfAssignment_1_2() { return cExpressionIfAssignment_1_2; }
		
		//Expression
		public RuleCall getExpressionIfExpressionParserRuleCall_1_2_0() { return cExpressionIfExpressionParserRuleCall_1_2_0; }
		
		//":"
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }
		
		//expressionElse=ConditionalExpression
		public Assignment getExpressionElseAssignment_1_4() { return cExpressionElseAssignment_1_4; }
		
		//ConditionalExpression
		public RuleCall getExpressionElseConditionalExpressionParserRuleCall_1_4_0() { return cExpressionElseConditionalExpressionParserRuleCall_1_4_0; }
	}
	public class InfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.InfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExpressionsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cExpressionsPrefixExpressionParserRuleCall_0_0 = (RuleCall)cExpressionsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cInfixOpParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsPrefixExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//InfixExpression:
		//	expressions+=PrefixExpression (InfixOp expressions+=PrefixExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//expressions+=PrefixExpression (InfixOp expressions+=PrefixExpression)*
		public Group getGroup() { return cGroup; }
		
		//expressions+=PrefixExpression
		public Assignment getExpressionsAssignment_0() { return cExpressionsAssignment_0; }
		
		//PrefixExpression
		public RuleCall getExpressionsPrefixExpressionParserRuleCall_0_0() { return cExpressionsPrefixExpressionParserRuleCall_0_0; }
		
		//(InfixOp expressions+=PrefixExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//InfixOp
		public RuleCall getInfixOpParserRuleCall_1_0() { return cInfixOpParserRuleCall_1_0; }
		
		//expressions+=PrefixExpression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//PrefixExpression
		public RuleCall getExpressionsPrefixExpressionParserRuleCall_1_1_0() { return cExpressionsPrefixExpressionParserRuleCall_1_1_0; }
	}
	public class InfixOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.InfixOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cEqualsSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cExclamationMarkEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cLessThanSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cGreaterThanSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cLessThanSignEqualsSignKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cGreaterThanSignEqualsSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cPlusSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cHyphenMinusKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cAsteriskKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final Keyword cSolidusKeyword_11 = (Keyword)cAlternatives.eContents().get(11);
		
		//InfixOp:
		//	"||" |
		//	"&&" |
		//	"==" |
		//	"!=" |
		//	"<" |
		//	">" |
		//	"<=" |
		//	">=" |
		//	"+" |
		//	"-" |
		//	"*" |
		//	"/";
		@Override public ParserRule getRule() { return rule; }
		
		//"||" | "&&" | "==" | "!=" | "<" | ">" | "<=" | ">=" | "+" | "-" | "*" | "/"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_0() { return cVerticalLineVerticalLineKeyword_0; }
		
		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1() { return cAmpersandAmpersandKeyword_1; }
		
		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_2() { return cEqualsSignEqualsSignKeyword_2; }
		
		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_3() { return cExclamationMarkEqualsSignKeyword_3; }
		
		//"<"
		public Keyword getLessThanSignKeyword_4() { return cLessThanSignKeyword_4; }
		
		//">"
		public Keyword getGreaterThanSignKeyword_5() { return cGreaterThanSignKeyword_5; }
		
		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_6() { return cLessThanSignEqualsSignKeyword_6; }
		
		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_7() { return cGreaterThanSignEqualsSignKeyword_7; }
		
		//"+"
		public Keyword getPlusSignKeyword_8() { return cPlusSignKeyword_8; }
		
		//"-"
		public Keyword getHyphenMinusKeyword_9() { return cHyphenMinusKeyword_9; }
		
		//"*"
		public Keyword getAsteriskKeyword_10() { return cAsteriskKeyword_10; }
		
		//"/"
		public Keyword getSolidusKeyword_11() { return cSolidusKeyword_11; }
	}
	public class PrefixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.PrefixExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cPrefixOpParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final RuleCall cPrefixExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cPostfixExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PrefixExpression:
		//	PrefixOp PrefixExpression | PostfixExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//PrefixOp PrefixExpression | PostfixExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PrefixOp PrefixExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//PrefixOp
		public RuleCall getPrefixOpParserRuleCall_0_0() { return cPrefixOpParserRuleCall_0_0; }
		
		//PrefixExpression
		public RuleCall getPrefixExpressionParserRuleCall_0_1() { return cPrefixExpressionParserRuleCall_0_1; }
		
		//PostfixExpression
		public RuleCall getPostfixExpressionParserRuleCall_1() { return cPostfixExpressionParserRuleCall_1; }
	}
	public class PrefixOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.PrefixOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//PrefixOp:
		//	"-" |
		//	"!";
		@Override public ParserRule getRule() { return rule; }
		
		//"-" | "!"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//"!"
		public Keyword getExclamationMarkKeyword_1() { return cExclamationMarkKeyword_1; }
	}
	public class PostfixExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.PostfixExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cSuffixesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSuffixesSuffixParserRuleCall_1_0 = (RuleCall)cSuffixesAssignment_1.eContents().get(0);
		
		//PostfixExpression:
		//	Primary suffixes+=Suffix*;
		@Override public ParserRule getRule() { return rule; }
		
		//Primary suffixes+=Suffix*
		public Group getGroup() { return cGroup; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }
		
		//suffixes+=Suffix*
		public Assignment getSuffixesAssignment_1() { return cSuffixesAssignment_1; }
		
		//Suffix
		public RuleCall getSuffixesSuffixParserRuleCall_1_0() { return cSuffixesSuffixParserRuleCall_1_0; }
	}
	public class SuffixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Suffix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArrayAccessParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFieldAccessParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cMethodInvocationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Suffix:
		//	ArrayAccess | FieldAccess | MethodInvocation;
		@Override public ParserRule getRule() { return rule; }
		
		//ArrayAccess | FieldAccess | MethodInvocation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ArrayAccess
		public RuleCall getArrayAccessParserRuleCall_0() { return cArrayAccessParserRuleCall_0; }
		
		//FieldAccess
		public RuleCall getFieldAccessParserRuleCall_1() { return cFieldAccessParserRuleCall_1; }
		
		//MethodInvocation
		public RuleCall getMethodInvocationParserRuleCall_2() { return cMethodInvocationParserRuleCall_2; }
	}
	public class ArrayAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ArrayAccess");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ArrayAccess:
		//	"[" expression=Expression "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" expression=Expression "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}
	public class SelectorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Selector");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Selector:
		//	"." Identifier;
		@Override public ParserRule getRule() { return rule; }
		
		//"." Identifier
		public Group getGroup() { return cGroup; }
		
		//"."
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_1() { return cIdentifierParserRuleCall_1; }
	}
	public class FieldAccessElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.FieldAccess");
		private final RuleCall cSelectorParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//FieldAccess:
		//	Selector;
		@Override public ParserRule getRule() { return rule; }
		
		//Selector
		public RuleCall getSelectorParserRuleCall() { return cSelectorParserRuleCall; }
	}
	public class MethodInvocationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.MethodInvocation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMethodInvocationAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cSelectorParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cArgumentsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cArgumentsArgumentListParserRuleCall_3_0 = (RuleCall)cArgumentsAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MethodInvocation:
		//	{MethodInvocation} Selector "(" arguments=ArgumentList? ")";
		@Override public ParserRule getRule() { return rule; }
		
		//{MethodInvocation} Selector "(" arguments=ArgumentList? ")"
		public Group getGroup() { return cGroup; }
		
		//{MethodInvocation}
		public Action getMethodInvocationAction_0() { return cMethodInvocationAction_0; }
		
		//Selector
		public RuleCall getSelectorParserRuleCall_1() { return cSelectorParserRuleCall_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//arguments=ArgumentList?
		public Assignment getArgumentsAssignment_3() { return cArgumentsAssignment_3; }
		
		//ArgumentList
		public RuleCall getArgumentsArgumentListParserRuleCall_3_0() { return cArgumentsArgumentListParserRuleCall_3_0; }
		
		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ArgumentListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ArgumentList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_1_1_0 = (RuleCall)cExpressionsAssignment_1_1.eContents().get(0);
		
		//ArgumentList:
		//	Expression (',' expressions+=Expression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Expression (',' expressions+=Expression)*
		public Group getGroup() { return cGroup; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0() { return cExpressionParserRuleCall_0; }
		
		//(',' expressions+=Expression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//expressions+=Expression
		public Assignment getExpressionsAssignment_1_1() { return cExpressionsAssignment_1_1; }
		
		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_1_1_0() { return cExpressionsExpressionParserRuleCall_1_1_0; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Keyword cThisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIdentifierParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cSuperKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cFieldAccessParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final Keyword cSuperKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final RuleCall cMethodInvocationParserRuleCall_5_1 = (RuleCall)cGroup_5.eContents().get(1);
		private final RuleCall cClassInstanceCreationExpressionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cArrayCreationExpressionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//Primary:
		//	"(" Expression ")" |
		//	"this" | Literal | Identifier |
		//	"super" FieldAccess |
		//	"super" MethodInvocation | ClassInstanceCreationExpression | ArrayCreationExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//"(" Expression ")" | "this" | Literal | Identifier | "super" FieldAccess | "super" MethodInvocation |
		//ClassInstanceCreationExpression | ArrayCreationExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }
		
		//"this"
		public Keyword getThisKeyword_1() { return cThisKeyword_1; }
		
		//Literal
		public RuleCall getLiteralParserRuleCall_2() { return cLiteralParserRuleCall_2; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_3() { return cIdentifierParserRuleCall_3; }
		
		//"super" FieldAccess
		public Group getGroup_4() { return cGroup_4; }
		
		//"super"
		public Keyword getSuperKeyword_4_0() { return cSuperKeyword_4_0; }
		
		//FieldAccess
		public RuleCall getFieldAccessParserRuleCall_4_1() { return cFieldAccessParserRuleCall_4_1; }
		
		//"super" MethodInvocation
		public Group getGroup_5() { return cGroup_5; }
		
		//"super"
		public Keyword getSuperKeyword_5_0() { return cSuperKeyword_5_0; }
		
		//MethodInvocation
		public RuleCall getMethodInvocationParserRuleCall_5_1() { return cMethodInvocationParserRuleCall_5_1; }
		
		//ClassInstanceCreationExpression
		public RuleCall getClassInstanceCreationExpressionParserRuleCall_6() { return cClassInstanceCreationExpressionParserRuleCall_6; }
		
		//ArrayCreationExpression
		public RuleCall getArrayCreationExpressionParserRuleCall_7() { return cArrayCreationExpressionParserRuleCall_7; }
	}
	public class ClassInstanceCreationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ClassInstanceCreationExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNewKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cClassTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ClassInstanceCreationExpression:
		//	"new" ClassType "(" ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"new" ClassType "(" ")"
		public Group getGroup() { return cGroup; }
		
		//"new"
		public Keyword getNewKeyword_0() { return cNewKeyword_0; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall_1() { return cClassTypeParserRuleCall_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class ArrayCreationExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.ArrayCreationExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cNewKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cPrimitiveTypeParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cExpressionAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_0_3_0 = (RuleCall)cExpressionAssignment_0_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final RuleCall cDimensionParserRuleCall_0_5 = (RuleCall)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNewKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cClassTypeParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExpressionAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_1_3_0 = (RuleCall)cExpressionAssignment_1_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		private final RuleCall cDimensionParserRuleCall_1_5 = (RuleCall)cGroup_1.eContents().get(5);
		
		//ArrayCreationExpression:
		//	"new" PrimitiveType "[" expression=Expression "]" Dimension* |
		//	"new" ClassType "[" expression=Expression "]" Dimension*;
		@Override public ParserRule getRule() { return rule; }
		
		//"new" PrimitiveType "[" expression=Expression "]" Dimension* | "new" ClassType "[" expression=Expression "]" Dimension*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//"new" PrimitiveType "[" expression=Expression "]" Dimension*
		public Group getGroup_0() { return cGroup_0; }
		
		//"new"
		public Keyword getNewKeyword_0_0() { return cNewKeyword_0_0; }
		
		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0_1() { return cPrimitiveTypeParserRuleCall_0_1; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0_2() { return cLeftSquareBracketKeyword_0_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_0_3() { return cExpressionAssignment_0_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_3_0() { return cExpressionExpressionParserRuleCall_0_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_0_4() { return cRightSquareBracketKeyword_0_4; }
		
		//Dimension*
		public RuleCall getDimensionParserRuleCall_0_5() { return cDimensionParserRuleCall_0_5; }
		
		//"new" ClassType "[" expression=Expression "]" Dimension*
		public Group getGroup_1() { return cGroup_1; }
		
		//"new"
		public Keyword getNewKeyword_1_0() { return cNewKeyword_1_0; }
		
		//ClassType
		public RuleCall getClassTypeParserRuleCall_1_1() { return cClassTypeParserRuleCall_1_1; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1_2() { return cLeftSquareBracketKeyword_1_2; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_1_3() { return cExpressionAssignment_1_3; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_3_0() { return cExpressionExpressionParserRuleCall_1_3_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_1_4() { return cRightSquareBracketKeyword_1_4; }
		
		//Dimension*
		public RuleCall getDimensionParserRuleCall_1_5() { return cDimensionParserRuleCall_1_5; }
	}
	public class DimensionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.Dimension");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Dimension:
		//	"[" "]";
		@Override public ParserRule getRule() { return rule; }
		
		//"[" "]"
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_1() { return cRightSquareBracketKeyword_1; }
	}
	
	
	private final GoalElements pGoal;
	private final LiteralElements pLiteral;
	private final TerminalRule tNullLiteral;
	private final TerminalRule tStringLiteral;
	private final TerminalRule tCharacterLiteral;
	private final TerminalRule tBooleanLiteral;
	private final TerminalRule tIntegerLiteral;
	private final TypeElements pType;
	private final PrimitiveTypeElements pPrimitiveType;
	private final ReferenceTypeElements pReferenceType;
	private final ClassTypeElements pClassType;
	private final ArrayTypeElements pArrayType;
	private final NameElements pName;
	private final SimpleNameElements pSimpleName;
	private final IdentifierElements pIdentifier;
	private final QualifiedNameElements pQualifiedName;
	private final CompilationUnitElements pCompilationUnit;
	private final TypeDeclarationElements pTypeDeclaration;
	private final ModifiersElements pModifiers;
	private final ModifierElements pModifier;
	private final ClassDeclarationElements pClassDeclaration;
	private final SuperElements pSuper;
	private final ClassBodyElements pClassBody;
	private final ClassMemberDeclarationElements pClassMemberDeclaration;
	private final FieldDeclarationElements pFieldDeclaration;
	private final IdentifierListElements pIdentifierList;
	private final MethodDeclarationElements pMethodDeclaration;
	private final MethodHeaderElements pMethodHeader;
	private final MethodDeclaratorElements pMethodDeclarator;
	private final FormalParameterListElements pFormalParameterList;
	private final FormalParameterElements pFormalParameter;
	private final ThrowsElements pThrows;
	private final MethodBodyElements pMethodBody;
	private final BlockElements pBlock;
	private final BlockStatementElements pBlockStatement;
	private final LocalVariableDeclarationStatementElements pLocalVariableDeclarationStatement;
	private final LocalVariableDeclarationElements pLocalVariableDeclaration;
	private final VariableDeclaratorsElements pVariableDeclarators;
	private final VariableDeclaratorElements pVariableDeclarator;
	private final StatementElements pStatement;
	private final ExpressionStatementElements pExpressionStatement;
	private final StatementExpressionElements pStatementExpression;
	private final IfThenStatementElements pIfThenStatement;
	private final IfThenElseStatementElements pIfThenElseStatement;
	private final WhileStatementElements pWhileStatement;
	private final DoWhileStatementElements pDoWhileStatement;
	private final ReturnStatementElements pReturnStatement;
	private final BreakStatementElements pBreakStatement;
	private final ContinueStatementElements pContinueStatement;
	private final ForStatementElements pForStatement;
	private final ForInitElements pForInit;
	private final ForUpdateElements pForUpdate;
	private final StatementExpressionListElements pStatementExpressionList;
	private final ExpressionElements pExpression;
	private final AssignmentExpressionElements pAssignmentExpression;
	private final ConditionalExpressionElements pConditionalExpression;
	private final InfixExpressionElements pInfixExpression;
	private final InfixOpElements pInfixOp;
	private final PrefixExpressionElements pPrefixExpression;
	private final PrefixOpElements pPrefixOp;
	private final PostfixExpressionElements pPostfixExpression;
	private final SuffixElements pSuffix;
	private final ArrayAccessElements pArrayAccess;
	private final SelectorElements pSelector;
	private final FieldAccessElements pFieldAccess;
	private final MethodInvocationElements pMethodInvocation;
	private final ArgumentListElements pArgumentList;
	private final PrimaryElements pPrimary;
	private final ClassInstanceCreationExpressionElements pClassInstanceCreationExpression;
	private final ArrayCreationExpressionElements pArrayCreationExpression;
	private final DimensionElements pDimension;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MiniJavaGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pGoal = new GoalElements();
		this.pLiteral = new LiteralElements();
		this.tNullLiteral = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.NullLiteral");
		this.tStringLiteral = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.StringLiteral");
		this.tCharacterLiteral = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.CharacterLiteral");
		this.tBooleanLiteral = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.BooleanLiteral");
		this.tIntegerLiteral = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.tetrabox.MiniJava.IntegerLiteral");
		this.pType = new TypeElements();
		this.pPrimitiveType = new PrimitiveTypeElements();
		this.pReferenceType = new ReferenceTypeElements();
		this.pClassType = new ClassTypeElements();
		this.pArrayType = new ArrayTypeElements();
		this.pName = new NameElements();
		this.pSimpleName = new SimpleNameElements();
		this.pIdentifier = new IdentifierElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.pCompilationUnit = new CompilationUnitElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pModifiers = new ModifiersElements();
		this.pModifier = new ModifierElements();
		this.pClassDeclaration = new ClassDeclarationElements();
		this.pSuper = new SuperElements();
		this.pClassBody = new ClassBodyElements();
		this.pClassMemberDeclaration = new ClassMemberDeclarationElements();
		this.pFieldDeclaration = new FieldDeclarationElements();
		this.pIdentifierList = new IdentifierListElements();
		this.pMethodDeclaration = new MethodDeclarationElements();
		this.pMethodHeader = new MethodHeaderElements();
		this.pMethodDeclarator = new MethodDeclaratorElements();
		this.pFormalParameterList = new FormalParameterListElements();
		this.pFormalParameter = new FormalParameterElements();
		this.pThrows = new ThrowsElements();
		this.pMethodBody = new MethodBodyElements();
		this.pBlock = new BlockElements();
		this.pBlockStatement = new BlockStatementElements();
		this.pLocalVariableDeclarationStatement = new LocalVariableDeclarationStatementElements();
		this.pLocalVariableDeclaration = new LocalVariableDeclarationElements();
		this.pVariableDeclarators = new VariableDeclaratorsElements();
		this.pVariableDeclarator = new VariableDeclaratorElements();
		this.pStatement = new StatementElements();
		this.pExpressionStatement = new ExpressionStatementElements();
		this.pStatementExpression = new StatementExpressionElements();
		this.pIfThenStatement = new IfThenStatementElements();
		this.pIfThenElseStatement = new IfThenElseStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pDoWhileStatement = new DoWhileStatementElements();
		this.pReturnStatement = new ReturnStatementElements();
		this.pBreakStatement = new BreakStatementElements();
		this.pContinueStatement = new ContinueStatementElements();
		this.pForStatement = new ForStatementElements();
		this.pForInit = new ForInitElements();
		this.pForUpdate = new ForUpdateElements();
		this.pStatementExpressionList = new StatementExpressionListElements();
		this.pExpression = new ExpressionElements();
		this.pAssignmentExpression = new AssignmentExpressionElements();
		this.pConditionalExpression = new ConditionalExpressionElements();
		this.pInfixExpression = new InfixExpressionElements();
		this.pInfixOp = new InfixOpElements();
		this.pPrefixExpression = new PrefixExpressionElements();
		this.pPrefixOp = new PrefixOpElements();
		this.pPostfixExpression = new PostfixExpressionElements();
		this.pSuffix = new SuffixElements();
		this.pArrayAccess = new ArrayAccessElements();
		this.pSelector = new SelectorElements();
		this.pFieldAccess = new FieldAccessElements();
		this.pMethodInvocation = new MethodInvocationElements();
		this.pArgumentList = new ArgumentListElements();
		this.pPrimary = new PrimaryElements();
		this.pClassInstanceCreationExpression = new ClassInstanceCreationExpressionElements();
		this.pArrayCreationExpression = new ArrayCreationExpressionElements();
		this.pDimension = new DimensionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.tetrabox.MiniJava".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///**
	// * Source: https://www.cs.purdue.edu/homes/hosking/502/project/grammar.html
	// */ // The Syntactic Grammar
	//Goal:
	//	CompilationUnit;
	public GoalElements getGoalAccess() {
		return pGoal;
	}
	
	public ParserRule getGoalRule() {
		return getGoalAccess().getRule();
	}
	
	////Lexical Structure
	////The Java lexical definition describes tokens for Identifier, and the various literals:
	//Literal:
	//	IntegerLiteral | BooleanLiteral | CharacterLiteral | StringLiteral | NullLiteral;
	public LiteralElements getLiteralAccess() {
		return pLiteral;
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}
	
	//terminal NullLiteral:
	//	"null";
	public TerminalRule getNullLiteralRule() {
		return tNullLiteral;
	}
	
	//terminal StringLiteral:
	//	STRING;
	public TerminalRule getStringLiteralRule() {
		return tStringLiteral;
	}
	
	//terminal CharacterLiteral:
	//	"\'" . "\'";
	public TerminalRule getCharacterLiteralRule() {
		return tCharacterLiteral;
	}
	
	//terminal BooleanLiteral:
	//	"true" | "false";
	public TerminalRule getBooleanLiteralRule() {
		return tBooleanLiteral;
	}
	
	//terminal IntegerLiteral:
	//	INT;
	public TerminalRule getIntegerLiteralRule() {
		return tIntegerLiteral;
	}
	
	//// In MiniJava we accept identifiers consisting of ASCII characters only, integer literals including octal and hexadecimal, and character and string literals consisting of ASCII characters only, and including escapes.
	//// Types
	//Type:
	//	PrimitiveType | ReferenceType;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//PrimitiveType:
	//	"int" |
	//	"boolean";
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return pPrimitiveType;
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}
	
	//ReferenceType:
	//	ClassType
	//	//   	|ArrayType
	//;
	public ReferenceTypeElements getReferenceTypeAccess() {
		return pReferenceType;
	}
	
	public ParserRule getReferenceTypeRule() {
		return getReferenceTypeAccess().getRule();
	}
	
	//ClassType:
	//	Name;
	public ClassTypeElements getClassTypeAccess() {
		return pClassType;
	}
	
	public ParserRule getClassTypeRule() {
		return getClassTypeAccess().getRule();
	}
	
	//ArrayType:
	//	PrimitiveType "[]" | ClassType "[]" | ArrayType "[]";
	public ArrayTypeElements getArrayTypeAccess() {
		return pArrayType;
	}
	
	public ParserRule getArrayTypeRule() {
		return getArrayTypeAccess().getRule();
	}
	
	////Names
	//Name:
	//	SimpleName | QualifiedName;
	public NameElements getNameAccess() {
		return pName;
	}
	
	public ParserRule getNameRule() {
		return getNameAccess().getRule();
	}
	
	//SimpleName:
	//	Identifier;
	public SimpleNameElements getSimpleNameAccess() {
		return pSimpleName;
	}
	
	public ParserRule getSimpleNameRule() {
		return getSimpleNameAccess().getRule();
	}
	
	//Identifier:
	//	ID;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	//QualifiedName:
	//	Identifier ('.' Identifier)*
	//	//  	Name "." Identifier // original rule
	//;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	////Packages
	//CompilationUnit:
	//	types+=TypeDeclaration+;
	public CompilationUnitElements getCompilationUnitAccess() {
		return pCompilationUnit;
	}
	
	public ParserRule getCompilationUnitRule() {
		return getCompilationUnitAccess().getRule();
	}
	
	//TypeDeclaration:
	//	ClassDeclaration;
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}
	
	////Modifiers
	//Modifiers:
	//	{Modifier} modifiers+=Modifier*;
	public ModifiersElements getModifiersAccess() {
		return pModifiers;
	}
	
	public ParserRule getModifiersRule() {
		return getModifiersAccess().getRule();
	}
	
	//Modifier:
	//	"public" |
	//	"static" |
	//	"native";
	public ModifierElements getModifierAccess() {
		return pModifier;
	}
	
	public ParserRule getModifierRule() {
		return getModifierAccess().getRule();
	}
	
	////Classes
	////Class Declaration
	//ClassDeclaration:
	//	'class' Identifier Super? ClassBody;
	public ClassDeclarationElements getClassDeclarationAccess() {
		return pClassDeclaration;
	}
	
	public ParserRule getClassDeclarationRule() {
		return getClassDeclarationAccess().getRule();
	}
	
	//Super:
	//	"extends" ClassType;
	public SuperElements getSuperAccess() {
		return pSuper;
	}
	
	public ParserRule getSuperRule() {
		return getSuperAccess().getRule();
	}
	
	//ClassBody:
	//	{ClassBody} '{' classMembers+=ClassMemberDeclaration* '}';
	public ClassBodyElements getClassBodyAccess() {
		return pClassBody;
	}
	
	public ParserRule getClassBodyRule() {
		return getClassBodyAccess().getRule();
	}
	
	//ClassMemberDeclaration:
	//	FieldDeclaration | MethodDeclaration;
	public ClassMemberDeclarationElements getClassMemberDeclarationAccess() {
		return pClassMemberDeclaration;
	}
	
	public ParserRule getClassMemberDeclarationRule() {
		return getClassMemberDeclarationAccess().getRule();
	}
	
	////Field Declarations
	//FieldDeclaration:
	//	Modifiers Type IdentifierList;
	public FieldDeclarationElements getFieldDeclarationAccess() {
		return pFieldDeclaration;
	}
	
	public ParserRule getFieldDeclarationRule() {
		return getFieldDeclarationAccess().getRule();
	}
	
	//IdentifierList:
	//	Identifier (',' Identifier)*;
	public IdentifierListElements getIdentifierListAccess() {
		return pIdentifierList;
	}
	
	public ParserRule getIdentifierListRule() {
		return getIdentifierListAccess().getRule();
	}
	
	////Method Declarations
	//MethodDeclaration:
	//	MethodHeader body=MethodBody;
	public MethodDeclarationElements getMethodDeclarationAccess() {
		return pMethodDeclaration;
	}
	
	public ParserRule getMethodDeclarationRule() {
		return getMethodDeclarationAccess().getRule();
	}
	
	//MethodHeader:
	//	Modifiers type=Type declarator=MethodDeclarator throws=Throws? | Modifiers "void" declarator=MethodDeclarator
	//	throws=Throws?;
	public MethodHeaderElements getMethodHeaderAccess() {
		return pMethodHeader;
	}
	
	public ParserRule getMethodHeaderRule() {
		return getMethodHeaderAccess().getRule();
	}
	
	//MethodDeclarator:
	//	Identifier "(" FormalParameterList? ")";
	public MethodDeclaratorElements getMethodDeclaratorAccess() {
		return pMethodDeclarator;
	}
	
	public ParserRule getMethodDeclaratorRule() {
		return getMethodDeclaratorAccess().getRule();
	}
	
	//FormalParameterList:
	//	FormalParameter (',' FormalParameter)*;
	public FormalParameterListElements getFormalParameterListAccess() {
		return pFormalParameterList;
	}
	
	public ParserRule getFormalParameterListRule() {
		return getFormalParameterListAccess().getRule();
	}
	
	//FormalParameter:
	//	Type Identifier;
	public FormalParameterElements getFormalParameterAccess() {
		return pFormalParameter;
	}
	
	public ParserRule getFormalParameterRule() {
		return getFormalParameterAccess().getRule();
	}
	
	//Throws:
	//	"throws" ClassType;
	public ThrowsElements getThrowsAccess() {
		return pThrows;
	}
	
	public ParserRule getThrowsRule() {
		return getThrowsAccess().getRule();
	}
	
	//MethodBody:
	//	Block;
	public MethodBodyElements getMethodBodyAccess() {
		return pMethodBody;
	}
	
	public ParserRule getMethodBodyRule() {
		return getMethodBodyAccess().getRule();
	}
	
	////Blocks and Statements
	//Block:
	//	{Block} "{" statements+=BlockStatement* "}";
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//BlockStatement:
	//	LocalVariableDeclarationStatement | Statement;
	public BlockStatementElements getBlockStatementAccess() {
		return pBlockStatement;
	}
	
	public ParserRule getBlockStatementRule() {
		return getBlockStatementAccess().getRule();
	}
	
	//LocalVariableDeclarationStatement:
	//	LocalVariableDeclaration;
	public LocalVariableDeclarationStatementElements getLocalVariableDeclarationStatementAccess() {
		return pLocalVariableDeclarationStatement;
	}
	
	public ParserRule getLocalVariableDeclarationStatementRule() {
		return getLocalVariableDeclarationStatementAccess().getRule();
	}
	
	//LocalVariableDeclaration:
	//	Type VariableDeclarators;
	public LocalVariableDeclarationElements getLocalVariableDeclarationAccess() {
		return pLocalVariableDeclaration;
	}
	
	public ParserRule getLocalVariableDeclarationRule() {
		return getLocalVariableDeclarationAccess().getRule();
	}
	
	//VariableDeclarators:
	//	variableDeclarators+=VariableDeclarator (',' variableDeclarators+=VariableDeclarator)*;
	public VariableDeclaratorsElements getVariableDeclaratorsAccess() {
		return pVariableDeclarators;
	}
	
	public ParserRule getVariableDeclaratorsRule() {
		return getVariableDeclaratorsAccess().getRule();
	}
	
	//VariableDeclarator:
	//	{VariableDeclarator} Identifier | Identifier "=" Expression;
	public VariableDeclaratorElements getVariableDeclaratorAccess() {
		return pVariableDeclarator;
	}
	
	public ParserRule getVariableDeclaratorRule() {
		return getVariableDeclaratorAccess().getRule();
	}
	
	//Statement:
	//	Block | ExpressionStatement | IfThenStatement | IfThenElseStatement | WhileStatement | DoWhileStatement |
	//	ReturnStatement | BreakStatement | ContinueStatement | ForStatement;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//ExpressionStatement:
	//	{ExpressionStatement} statementExpression=StatementExpression?;
	public ExpressionStatementElements getExpressionStatementAccess() {
		return pExpressionStatement;
	}
	
	public ParserRule getExpressionStatementRule() {
		return getExpressionStatementAccess().getRule();
	}
	
	//StatementExpression:
	//	Expression;
	public StatementExpressionElements getStatementExpressionAccess() {
		return pStatementExpression;
	}
	
	public ParserRule getStatementExpressionRule() {
		return getStatementExpressionAccess().getRule();
	}
	
	//IfThenStatement:
	//	"if" "(" Expression ")" statement=Statement;
	public IfThenStatementElements getIfThenStatementAccess() {
		return pIfThenStatement;
	}
	
	public ParserRule getIfThenStatementRule() {
		return getIfThenStatementAccess().getRule();
	}
	
	//IfThenElseStatement:
	//	"if" "(" Expression ")" statementIf=Statement "else" statementElse=Statement;
	public IfThenElseStatementElements getIfThenElseStatementAccess() {
		return pIfThenElseStatement;
	}
	
	public ParserRule getIfThenElseStatementRule() {
		return getIfThenElseStatementAccess().getRule();
	}
	
	//WhileStatement:
	//	"while" "(" Expression ")" statement=Statement;
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//DoWhileStatement:
	//	"do" statement=Statement "while" "(" expression=Expression ")";
	public DoWhileStatementElements getDoWhileStatementAccess() {
		return pDoWhileStatement;
	}
	
	public ParserRule getDoWhileStatementRule() {
		return getDoWhileStatementAccess().getRule();
	}
	
	//ReturnStatement:
	//	"return" Expression?;
	public ReturnStatementElements getReturnStatementAccess() {
		return pReturnStatement;
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}
	
	//BreakStatement:
	//	"break";
	public BreakStatementElements getBreakStatementAccess() {
		return pBreakStatement;
	}
	
	public ParserRule getBreakStatementRule() {
		return getBreakStatementAccess().getRule();
	}
	
	//ContinueStatement:
	//	"continue";
	public ContinueStatementElements getContinueStatementAccess() {
		return pContinueStatement;
	}
	
	public ParserRule getContinueStatementRule() {
		return getContinueStatementAccess().getRule();
	}
	
	//ForStatement:
	//	"for" "(" ForInit? ";" expression=Expression? ";" update=ForUpdate? ")" statement=Statement;
	public ForStatementElements getForStatementAccess() {
		return pForStatement;
	}
	
	public ParserRule getForStatementRule() {
		return getForStatementAccess().getRule();
	}
	
	//ForInit:
	//	StatementExpressionList | LocalVariableDeclaration;
	public ForInitElements getForInitAccess() {
		return pForInit;
	}
	
	public ParserRule getForInitRule() {
		return getForInitAccess().getRule();
	}
	
	//ForUpdate:
	//	StatementExpressionList;
	public ForUpdateElements getForUpdateAccess() {
		return pForUpdate;
	}
	
	public ParserRule getForUpdateRule() {
		return getForUpdateAccess().getRule();
	}
	
	//StatementExpressionList:
	//	statementExpressions+=StatementExpression ("," statementExpressions+=StatementExpression)*;
	public StatementExpressionListElements getStatementExpressionListAccess() {
		return pStatementExpressionList;
	}
	
	public ParserRule getStatementExpressionListRule() {
		return getStatementExpressionListAccess().getRule();
	}
	
	////Expressions
	//Expression:
	//	ConditionalExpression | AssignmentExpression;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//AssignmentExpression:
	//	left=ConditionalExpression "=" right=Expression;
	public AssignmentExpressionElements getAssignmentExpressionAccess() {
		return pAssignmentExpression;
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}
	
	//ConditionalExpression:
	//	InfixExpression | condition=InfixExpression "?" expressionIf=Expression ":" expressionElse=ConditionalExpression;
	public ConditionalExpressionElements getConditionalExpressionAccess() {
		return pConditionalExpression;
	}
	
	public ParserRule getConditionalExpressionRule() {
		return getConditionalExpressionAccess().getRule();
	}
	
	//InfixExpression:
	//	expressions+=PrefixExpression (InfixOp expressions+=PrefixExpression)*;
	public InfixExpressionElements getInfixExpressionAccess() {
		return pInfixExpression;
	}
	
	public ParserRule getInfixExpressionRule() {
		return getInfixExpressionAccess().getRule();
	}
	
	//InfixOp:
	//	"||" |
	//	"&&" |
	//	"==" |
	//	"!=" |
	//	"<" |
	//	">" |
	//	"<=" |
	//	">=" |
	//	"+" |
	//	"-" |
	//	"*" |
	//	"/";
	public InfixOpElements getInfixOpAccess() {
		return pInfixOp;
	}
	
	public ParserRule getInfixOpRule() {
		return getInfixOpAccess().getRule();
	}
	
	//PrefixExpression:
	//	PrefixOp PrefixExpression | PostfixExpression;
	public PrefixExpressionElements getPrefixExpressionAccess() {
		return pPrefixExpression;
	}
	
	public ParserRule getPrefixExpressionRule() {
		return getPrefixExpressionAccess().getRule();
	}
	
	//PrefixOp:
	//	"-" |
	//	"!";
	public PrefixOpElements getPrefixOpAccess() {
		return pPrefixOp;
	}
	
	public ParserRule getPrefixOpRule() {
		return getPrefixOpAccess().getRule();
	}
	
	//PostfixExpression:
	//	Primary suffixes+=Suffix*;
	public PostfixExpressionElements getPostfixExpressionAccess() {
		return pPostfixExpression;
	}
	
	public ParserRule getPostfixExpressionRule() {
		return getPostfixExpressionAccess().getRule();
	}
	
	//Suffix:
	//	ArrayAccess | FieldAccess | MethodInvocation;
	public SuffixElements getSuffixAccess() {
		return pSuffix;
	}
	
	public ParserRule getSuffixRule() {
		return getSuffixAccess().getRule();
	}
	
	//ArrayAccess:
	//	"[" expression=Expression "]";
	public ArrayAccessElements getArrayAccessAccess() {
		return pArrayAccess;
	}
	
	public ParserRule getArrayAccessRule() {
		return getArrayAccessAccess().getRule();
	}
	
	//Selector:
	//	"." Identifier;
	public SelectorElements getSelectorAccess() {
		return pSelector;
	}
	
	public ParserRule getSelectorRule() {
		return getSelectorAccess().getRule();
	}
	
	//FieldAccess:
	//	Selector;
	public FieldAccessElements getFieldAccessAccess() {
		return pFieldAccess;
	}
	
	public ParserRule getFieldAccessRule() {
		return getFieldAccessAccess().getRule();
	}
	
	//MethodInvocation:
	//	{MethodInvocation} Selector "(" arguments=ArgumentList? ")";
	public MethodInvocationElements getMethodInvocationAccess() {
		return pMethodInvocation;
	}
	
	public ParserRule getMethodInvocationRule() {
		return getMethodInvocationAccess().getRule();
	}
	
	//ArgumentList:
	//	Expression (',' expressions+=Expression)*;
	public ArgumentListElements getArgumentListAccess() {
		return pArgumentList;
	}
	
	public ParserRule getArgumentListRule() {
		return getArgumentListAccess().getRule();
	}
	
	//Primary:
	//	"(" Expression ")" |
	//	"this" | Literal | Identifier |
	//	"super" FieldAccess |
	//	"super" MethodInvocation | ClassInstanceCreationExpression | ArrayCreationExpression;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//ClassInstanceCreationExpression:
	//	"new" ClassType "(" ")";
	public ClassInstanceCreationExpressionElements getClassInstanceCreationExpressionAccess() {
		return pClassInstanceCreationExpression;
	}
	
	public ParserRule getClassInstanceCreationExpressionRule() {
		return getClassInstanceCreationExpressionAccess().getRule();
	}
	
	//ArrayCreationExpression:
	//	"new" PrimitiveType "[" expression=Expression "]" Dimension* |
	//	"new" ClassType "[" expression=Expression "]" Dimension*;
	public ArrayCreationExpressionElements getArrayCreationExpressionAccess() {
		return pArrayCreationExpression;
	}
	
	public ParserRule getArrayCreationExpressionRule() {
		return getArrayCreationExpressionAccess().getRule();
	}
	
	//Dimension:
	//	"[" "]";
	public DimensionElements getDimensionAccess() {
		return pDimension;
	}
	
	public ParserRule getDimensionRule() {
		return getDimensionAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
