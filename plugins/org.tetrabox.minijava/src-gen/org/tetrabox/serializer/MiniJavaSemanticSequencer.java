/*
 * generated by Xtext 2.12.0
 */
package org.tetrabox.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tetrabox.miniJava.ArrayAccess;
import org.tetrabox.miniJava.ArrayCreationExpression;
import org.tetrabox.miniJava.AssignmentExpression;
import org.tetrabox.miniJava.Block;
import org.tetrabox.miniJava.ClassBody;
import org.tetrabox.miniJava.CompilationUnit;
import org.tetrabox.miniJava.ConditionalExpression;
import org.tetrabox.miniJava.DoWhileStatement;
import org.tetrabox.miniJava.ExpressionStatement;
import org.tetrabox.miniJava.ForStatement;
import org.tetrabox.miniJava.InfixExpression;
import org.tetrabox.miniJava.MethodInvocation;
import org.tetrabox.miniJava.MiniJavaPackage;
import org.tetrabox.miniJava.Modifier;
import org.tetrabox.miniJava.PostfixExpression;
import org.tetrabox.miniJava.StatementExpressionList;
import org.tetrabox.miniJava.VariableDeclarator;
import org.tetrabox.miniJava.VariableDeclarators;
import org.tetrabox.services.MiniJavaGrammarAccess;

@SuppressWarnings("all")
public class MiniJavaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniJavaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniJavaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniJavaPackage.ARRAY_ACCESS:
				sequence_ArrayAccess(context, (ArrayAccess) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_CREATION_EXPRESSION:
				if (rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getArrayCreationExpressionRule()) {
					sequence_ArrayCreationExpression(context, (ArrayCreationExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_ArrayCreationExpression_PostfixExpression(context, (ArrayCreationExpression) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.ASSIGNMENT_EXPRESSION:
				if (rule == grammarAccess.getArgumentListRule()) {
					sequence_ArgumentList_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclaratorRule()
						|| rule == grammarAccess.getStatementExpressionRule()
						|| rule == grammarAccess.getReturnStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenElseStatementRule()) {
					sequence_AssignmentExpression_IfThenElseStatement(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_AssignmentExpression_IfThenElseStatement_IfThenStatement_WhileStatement(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenStatementRule()) {
					sequence_AssignmentExpression_IfThenStatement(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_AssignmentExpression_PostfixExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWhileStatementRule()) {
					sequence_AssignmentExpression_WhileStatement(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MiniJavaPackage.CLASS_BODY:
				sequence_ClassBody(context, (ClassBody) semanticObject); 
				return; 
			case MiniJavaPackage.COMPILATION_UNIT:
				sequence_CompilationUnit(context, (CompilationUnit) semanticObject); 
				return; 
			case MiniJavaPackage.CONDITIONAL_EXPRESSION:
				if (rule == grammarAccess.getArgumentListRule()) {
					sequence_ArgumentList_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclaratorRule()
						|| rule == grammarAccess.getStatementExpressionRule()
						|| rule == grammarAccess.getReturnStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenElseStatementRule()) {
					sequence_ConditionalExpression_IfThenElseStatement(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ConditionalExpression_IfThenElseStatement_IfThenStatement_WhileStatement(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenStatementRule()) {
					sequence_ConditionalExpression_IfThenStatement(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_ConditionalExpression_PostfixExpression(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWhileStatementRule()) {
					sequence_ConditionalExpression_WhileStatement(context, (ConditionalExpression) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.DO_WHILE_STATEMENT:
				sequence_DoWhileStatement(context, (DoWhileStatement) semanticObject); 
				return; 
			case MiniJavaPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case MiniJavaPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MiniJavaPackage.INFIX_EXPRESSION:
				if (rule == grammarAccess.getArgumentListRule()) {
					sequence_ArgumentList_InfixExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_IfThenElseStatement_IfThenStatement_InfixExpression_WhileStatement(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenElseStatementRule()) {
					sequence_IfThenElseStatement_InfixExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfThenStatementRule()) {
					sequence_IfThenStatement_InfixExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclaratorRule()
						|| rule == grammarAccess.getStatementExpressionRule()
						|| rule == grammarAccess.getReturnStatementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConditionalExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_InfixExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_InfixExpression_PostfixExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWhileStatementRule()) {
					sequence_InfixExpression_WhileStatement(context, (InfixExpression) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.METHOD_INVOCATION:
				if (rule == grammarAccess.getSuffixRule()
						|| rule == grammarAccess.getMethodInvocationRule()
						|| rule == grammarAccess.getPrimaryRule()) {
					sequence_MethodInvocation(context, (MethodInvocation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrefixExpressionRule()
						|| rule == grammarAccess.getPostfixExpressionRule()) {
					sequence_MethodInvocation_PostfixExpression(context, (MethodInvocation) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.MODIFIER:
				if (rule == grammarAccess.getClassMemberDeclarationRule()) {
					sequence_MethodDeclaration_MethodHeader_Modifiers(context, (Modifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodDeclarationRule()) {
					sequence_MethodDeclaration_MethodHeader_Modifiers(context, (Modifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodHeaderRule()) {
					sequence_MethodHeader_Modifiers(context, (Modifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getModifiersRule()
						|| rule == grammarAccess.getFieldDeclarationRule()) {
					sequence_Modifiers(context, (Modifier) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case MiniJavaPackage.STATEMENT_EXPRESSION_LIST:
				if (rule == grammarAccess.getBlockStatementRule()
						|| rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getForStatementRule()) {
					sequence_ForStatement_StatementExpressionList(context, (StatementExpressionList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForInitRule()
						|| rule == grammarAccess.getForUpdateRule()
						|| rule == grammarAccess.getStatementExpressionListRule()) {
					sequence_StatementExpressionList(context, (StatementExpressionList) semanticObject); 
					return; 
				}
				else break;
			case MiniJavaPackage.VARIABLE_DECLARATOR:
				sequence_VariableDeclarator(context, (VariableDeclarator) semanticObject); 
				return; 
			case MiniJavaPackage.VARIABLE_DECLARATORS:
				if (rule == grammarAccess.getBlockStatementRule()) {
					sequence_ForStatement_VariableDeclarators(context, (VariableDeclarators) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()
						|| rule == grammarAccess.getForStatementRule()) {
					sequence_ForStatement_VariableDeclarators(context, (VariableDeclarators) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLocalVariableDeclarationStatementRule()
						|| rule == grammarAccess.getLocalVariableDeclarationRule()
						|| rule == grammarAccess.getVariableDeclaratorsRule()
						|| rule == grammarAccess.getForInitRule()) {
					sequence_VariableDeclarators(context, (VariableDeclarators) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArgumentList returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression expressions+=Expression*)
	 */
	protected void sequence_ArgumentList_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression expressions+=Expression*)
	 */
	protected void sequence_ArgumentList_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentList returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression* expressions+=Expression*)
	 */
	protected void sequence_ArgumentList_InfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Suffix returns ArrayAccess
	 *     ArrayAccess returns ArrayAccess
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ArrayAccess(ISerializationContext context, ArrayAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayAccessAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Primary returns ArrayCreationExpression
	 *     ArrayCreationExpression returns ArrayCreationExpression
	 *
	 * Constraint:
	 *     (expression=Expression | expression=Expression)
	 */
	protected void sequence_ArrayCreationExpression(ISerializationContext context, ArrayCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns ArrayCreationExpression
	 *     PostfixExpression returns ArrayCreationExpression
	 *
	 * Constraint:
	 *     ((expression=Expression | expression=Expression) suffixes+=Suffix*)
	 */
	protected void sequence_ArrayCreationExpression_PostfixExpression(ISerializationContext context, ArrayCreationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns AssignmentExpression
	 *     StatementExpression returns AssignmentExpression
	 *     ReturnStatement returns AssignmentExpression
	 *     Expression returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     Primary returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getLeftConditionalExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfThenElseStatement returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression statementIf=Statement statementElse=Statement)
	 */
	protected void sequence_AssignmentExpression_IfThenElseStatement(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getLeftConditionalExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getStatementIfStatementParserRuleCall_4_0(), semanticObject.getStatementIf());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getStatementElseStatementParserRuleCall_6_0(), semanticObject.getStatementElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns AssignmentExpression
	 *     Statement returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression (statement=Statement | (statementIf=Statement statementElse=Statement) | statement=Statement)?)
	 */
	protected void sequence_AssignmentExpression_IfThenElseStatement_IfThenStatement_WhileStatement(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfThenStatement returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression statement=Statement)
	 */
	protected void sequence_AssignmentExpression_IfThenStatement(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getLeftConditionalExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getIfThenStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns AssignmentExpression
	 *     PostfixExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression suffixes+=Suffix*)
	 */
	protected void sequence_AssignmentExpression_PostfixExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileStatement returns AssignmentExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression right=Expression statement=Statement)
	 */
	protected void sequence_AssignmentExpression_WhileStatement(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getLeftConditionalExpressionParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExpressionParserRuleCall_2_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodBody returns Block
	 *     Block returns Block
	 *     BlockStatement returns Block
	 *     Statement returns Block
	 *
	 * Constraint:
	 *     statements+=BlockStatement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns ClassBody
	 *     ClassDeclaration returns ClassBody
	 *     ClassBody returns ClassBody
	 *
	 * Constraint:
	 *     classMembers+=ClassMemberDeclaration*
	 */
	protected void sequence_ClassBody(ISerializationContext context, ClassBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Goal returns CompilationUnit
	 *     CompilationUnit returns CompilationUnit
	 *
	 * Constraint:
	 *     types+=TypeDeclaration+
	 */
	protected void sequence_CompilationUnit(ISerializationContext context, CompilationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns ConditionalExpression
	 *     StatementExpression returns ConditionalExpression
	 *     ReturnStatement returns ConditionalExpression
	 *     Expression returns ConditionalExpression
	 *     ConditionalExpression returns ConditionalExpression
	 *     Primary returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionInfixExpressionParserRuleCall_1_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionIfExpressionParserRuleCall_1_2_0(), semanticObject.getExpressionIf());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionElseConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getExpressionElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfThenElseStatement returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression statementIf=Statement statementElse=Statement)
	 */
	protected void sequence_ConditionalExpression_IfThenElseStatement(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT_ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionInfixExpressionParserRuleCall_1_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionIfExpressionParserRuleCall_1_2_0(), semanticObject.getExpressionIf());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionElseConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getExpressionElse());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getStatementIfStatementParserRuleCall_4_0(), semanticObject.getStatementIf());
		feeder.accept(grammarAccess.getIfThenElseStatementAccess().getStatementElseStatementParserRuleCall_6_0(), semanticObject.getStatementElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ConditionalExpression
	 *     Statement returns ConditionalExpression
	 *
	 * Constraint:
	 *     (
	 *         condition=InfixExpression 
	 *         expressionIf=Expression 
	 *         expressionElse=ConditionalExpression 
	 *         (statement=Statement | (statementIf=Statement statementElse=Statement) | statement=Statement)?
	 *     )
	 */
	protected void sequence_ConditionalExpression_IfThenElseStatement_IfThenStatement_WhileStatement(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfThenStatement returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression statement=Statement)
	 */
	protected void sequence_ConditionalExpression_IfThenStatement(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionInfixExpressionParserRuleCall_1_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionIfExpressionParserRuleCall_1_2_0(), semanticObject.getExpressionIf());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionElseConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getExpressionElse());
		feeder.accept(grammarAccess.getIfThenStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns ConditionalExpression
	 *     PostfixExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression suffixes+=Suffix*)
	 */
	protected void sequence_ConditionalExpression_PostfixExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileStatement returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=InfixExpression expressionIf=Expression expressionElse=ConditionalExpression statement=Statement)
	 */
	protected void sequence_ConditionalExpression_WhileStatement(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_IF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION_ELSE));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EXPRESSION__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionInfixExpressionParserRuleCall_1_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionIfExpressionParserRuleCall_1_2_0(), semanticObject.getExpressionIf());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionElseConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getExpressionElse());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementParserRuleCall_4_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns DoWhileStatement
	 *     Statement returns DoWhileStatement
	 *     DoWhileStatement returns DoWhileStatement
	 *
	 * Constraint:
	 *     (statement=Statement expression=Expression)
	 */
	protected void sequence_DoWhileStatement(ISerializationContext context, DoWhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.DO_WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.DO_WHILE_STATEMENT__STATEMENT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.DO_WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.DO_WHILE_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileStatementAccess().getStatementStatementParserRuleCall_1_0(), semanticObject.getStatement());
		feeder.accept(grammarAccess.getDoWhileStatementAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     statementExpression=StatementExpression?
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns ForStatement
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (expression=Expression? update=ForUpdate? statement=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns StatementExpressionList
	 *     Statement returns StatementExpressionList
	 *     ForStatement returns StatementExpressionList
	 *
	 * Constraint:
	 *     (
	 *         statementExpressions+=StatementExpression 
	 *         statementExpressions+=StatementExpression* 
	 *         expression=Expression? 
	 *         update=ForUpdate? 
	 *         statement=Statement
	 *     )
	 */
	protected void sequence_ForStatement_StatementExpressionList(ISerializationContext context, StatementExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns VariableDeclarators
	 *
	 * Constraint:
	 *     (
	 *         variableDeclarators+=VariableDeclarator 
	 *         variableDeclarators+=VariableDeclarator* 
	 *         (expression=Expression? update=ForUpdate? statement=Statement)?
	 *     )
	 */
	protected void sequence_ForStatement_VariableDeclarators(ISerializationContext context, VariableDeclarators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     Statement returns VariableDeclarators
	//     ForStatement returns VariableDeclarators
	//
	// Constraint:
	//     (variableDeclarators+=VariableDeclarator variableDeclarators+=VariableDeclarator* expression=Expression? update=ForUpdate? statement=Statement)
	//
	// protected void sequence_ForStatement_VariableDeclarators(ISerializationContext context, VariableDeclarators semanticObject) { }
	
	/**
	 * Contexts:
	 *     BlockStatement returns InfixExpression
	 *     Statement returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         expressions+=PrefixExpression 
	 *         expressions+=PrefixExpression* 
	 *         (statement=Statement | (statementIf=Statement statementElse=Statement) | statement=Statement)?
	 *     )
	 */
	protected void sequence_IfThenElseStatement_IfThenStatement_InfixExpression_WhileStatement(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfThenElseStatement returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression* statementIf=Statement statementElse=Statement)
	 */
	protected void sequence_IfThenElseStatement_InfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfThenStatement returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression* statement=Statement)
	 */
	protected void sequence_IfThenStatement_InfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns InfixExpression
	 *     StatementExpression returns InfixExpression
	 *     ReturnStatement returns InfixExpression
	 *     Expression returns InfixExpression
	 *     ConditionalExpression returns InfixExpression
	 *     InfixExpression returns InfixExpression
	 *     Primary returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression*)
	 */
	protected void sequence_InfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns InfixExpression
	 *     PostfixExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression* suffixes+=Suffix*)
	 */
	protected void sequence_InfixExpression_PostfixExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileStatement returns InfixExpression
	 *
	 * Constraint:
	 *     (expressions+=PrefixExpression expressions+=PrefixExpression* statement=Statement)
	 */
	protected void sequence_InfixExpression_WhileStatement(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassMemberDeclaration returns Modifier
	 *
	 * Constraint:
	 *     (
	 *         modifiers+=Modifier* 
	 *         (((type=Type declarator=MethodDeclarator throws=Throws?) | (declarator=MethodDeclarator throws=Throws?)) body=MethodBody)?
	 *     )
	 */
	protected void sequence_MethodDeclaration_MethodHeader_Modifiers(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     MethodDeclaration returns Modifier
	//
	// Constraint:
	//     (modifiers+=Modifier* ((type=Type declarator=MethodDeclarator throws=Throws?) | (declarator=MethodDeclarator throws=Throws?)) body=MethodBody)
	//
	// protected void sequence_MethodDeclaration_MethodHeader_Modifiers(ISerializationContext context, Modifier semanticObject) { }
	
	/**
	 * Contexts:
	 *     MethodHeader returns Modifier
	 *
	 * Constraint:
	 *     (modifiers+=Modifier* ((type=Type declarator=MethodDeclarator throws=Throws?) | (declarator=MethodDeclarator throws=Throws?)))
	 */
	protected void sequence_MethodHeader_Modifiers(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Suffix returns MethodInvocation
	 *     MethodInvocation returns MethodInvocation
	 *     Primary returns MethodInvocation
	 *
	 * Constraint:
	 *     arguments=ArgumentList?
	 */
	protected void sequence_MethodInvocation(ISerializationContext context, MethodInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns MethodInvocation
	 *     PostfixExpression returns MethodInvocation
	 *
	 * Constraint:
	 *     (arguments=ArgumentList? suffixes+=Suffix*)
	 */
	protected void sequence_MethodInvocation_PostfixExpression(ISerializationContext context, MethodInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifiers returns Modifier
	 *     FieldDeclaration returns Modifier
	 *
	 * Constraint:
	 *     modifiers+=Modifier*
	 */
	protected void sequence_Modifiers(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrefixExpression returns PostfixExpression
	 *     PostfixExpression returns PostfixExpression
	 *
	 * Constraint:
	 *     suffixes+=Suffix+
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForInit returns StatementExpressionList
	 *     ForUpdate returns StatementExpressionList
	 *     StatementExpressionList returns StatementExpressionList
	 *
	 * Constraint:
	 *     (statementExpressions+=StatementExpression statementExpressions+=StatementExpression*)
	 */
	protected void sequence_StatementExpressionList(ISerializationContext context, StatementExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarator returns VariableDeclarator
	 *
	 * Constraint:
	 *     {VariableDeclarator}
	 */
	protected void sequence_VariableDeclarator(ISerializationContext context, VariableDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariableDeclarationStatement returns VariableDeclarators
	 *     LocalVariableDeclaration returns VariableDeclarators
	 *     VariableDeclarators returns VariableDeclarators
	 *     ForInit returns VariableDeclarators
	 *
	 * Constraint:
	 *     (variableDeclarators+=VariableDeclarator variableDeclarators+=VariableDeclarator*)
	 */
	protected void sequence_VariableDeclarators(ISerializationContext context, VariableDeclarators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
